mod STREAMS is
    protecting NAT .
    protecting QID .
    protecting CONVERSION .

    sorts TyQuant Mode Ty BaseTy Expr Id Val MultisetVal Multiset .
    subsort Nat < TyQuant .
    subsort Val < Expr .
    subsort Val < MultisetVal < Multiset .
    subsort Expr < Multiset .
    subsort Id < Val .

    ops * oo : -> TyQuant [ctor] .
    ops asset nonasset : -> Mode [ctor] .

    op ___ : TyQuant Mode BaseTy -> Ty [ctor] .

    op unit : -> BaseTy [ctor] .
    op multiset_ : Ty -> BaseTy [ctor] .
    op _x_ : Ty Ty -> BaseTy [ctor] .
    op _->_ : Ty Ty -> BaseTy [ctor] .

    subsort Qid < Expr .
    op lambda_:_._ : Qid Ty Expr -> Val [ctor] .

    op mt : -> MultisetVal [ctor] .
    op _,_ : MultisetVal MultisetVal -> MultisetVal [ctor comm assoc id: mt] .
    op _,_ : Multiset Multiset -> Multiset [ctor comm assoc id: mt] .
    op {_} : MultisetVal -> Val [ctor] .
    op {_} : Multiset -> Expr [ctor] .

    op id(_) : Nat -> Id [ctor] .

    op [_;_] : Val Val -> Val [ctor] .
    op [_;_] : Expr Expr -> Expr [ctor] .

    op __ : Expr Expr -> Expr [ctor] .

    ops zero fail : -> Val [ctor] .
    op sum : Expr -> Expr [ctor] .
    op sub : Expr Expr -> Expr [ctor] .

    op let[_;_]:=_in_ : Qid Qid Expr Expr -> Expr [ctor] .
    op let[_]:=_in_ : Qid Expr Expr -> Expr [ctor] .

    op try{_}catch{_} : Expr Expr -> Expr [ctor] .

    op assert_is_in_ : Expr TyQuant Expr -> Expr [ctor] .
    op groupWith : TyQuant Expr Expr Expr -> Expr [ctor] .
    op label : Expr -> Expr [ctor] .

    op copy : Expr -> Expr [ctor] .

    vars Q R Q1 Q2 : TyQuant .
    vars X Y Z A B : Qid .
    vars T S T1 T2 : BaseTy .
    vars Tau Sigma Pi : Ty .
    vars M : Mode .
    vars V W V1 V2 Left Right : Val .
    vars E F E1 E2 E3 E4 : Expr .
    vars Vs Ws Taken1 Taken2 Rest Rest1 Rest2 : Multiset .
    vars N N1 N2 : Nat .
    vars I J K L K1 K2 : Id .

    op demote : Ty -> Ty .
    eq demote(Q M T) = Q nonasset demoteBase(T) .

    op demoteBase : BaseTy -> BaseTy .
    eq demoteBase(unit) = unit .
    eq demoteBase(multiset Tau) = multiset demote(Tau) .
    eq demoteBase(Tau x Sigma) = demote(Tau) x demote(Sigma) .
    eq demoteBase(Tau -> Sigma) = demote(Tau) -> demote(Sigma) .

    op _in_ : Qid Multiset -> Bool .
    eq X in (X, Vs) = true .
    eq X in Vs = false [owise] .

    op freshVar : Multiset -> Qid .
    eq freshVar(Vs) = freshVar(0, Vs) .
    op freshVar : Nat Multiset -> Qid .
    eq freshVar(N, Vs) =
        if qid(string(N, 10)) in Vs then
            freshVar(N + 1, Vs)
        else
            qid(string(N, 10))
        fi .

    op varsOf : Expr -> Multiset .
    op varsOf : Multiset -> Multiset .
    eq varsOf(X) = X .
    eq varsOf(lambda X : Tau . E1) = X, varsOf(E1) .
    eq varsOf(mt) = mt .
    eq varsOf(E1 E2) = varsOf(E1), varsOf(E2) .
    eq varsOf(E1, E2) = varsOf(E1), varsOf(E2) .
    eq varsOf({ E }) = varsOf(E) .
    eq varsOf([E1 ; E2]) = varsOf(E2), varsOf(E2) .
    eq varsOf(zero) = mt .
    eq varsOf(fail) = mt .
    eq varsOf(sum(E)) = varsOf(E) .
    eq varsOf(sub(E1, E2)) = varsOf(E1), varsOf(E2) .
    eq varsOf(let [ X ; Y ] := E1 in E2) = X, Y, varsOf(E1), varsOf(E2) .
    eq varsOf(let [ X ] := E1 in E2) = X, varsOf(E1), varsOf(E2) .
    eq varsOf(try { E1 } catch { E2 }) = varsOf(E1), varsOf(E2) .
    eq varsOf(assert E1 is Q in E2) = varsOf(E1), varsOf(E2) .
    eq varsOf(groupWith(Q, F, E1, E2)) = varsOf(F), varsOf(E1), varsOf(E2) .
    eq varsOf(label(E)) = varsOf(E) .
    eq varsOf(copy(E)) = varsOf(E) .

    op _[_/_] : Expr Expr Qid -> Expr .
    op _[_/_] : Multiset Expr Qid -> Multiset .
    eq X[E / Y] = if X == Y then E else X fi .
    ceq (lambda X : Tau . E1)[E / Y] = lambda X : Tau . (E1[E / Y])
        if not (X in Y, varsOf(E)) .
    ceq (lambda X : Tau . E1)[E / Y] = (lambda Z : Tau . (E1[Z / X]))[E / Y]
        if (X in Y, varsOf(E)) /\
            Z := freshVar(varsOf(E1), X, Y, varsOf(E)) .
    eq zero[E / Y] = zero .
    eq fail[E / Y] = fail .
    eq mt[E / Y] = mt .
    eq id(N)[E / Y] = id(N) .
    eq (E1, E2)[E / Y] = (E1[E / Y]), (E2[E / Y]) .
    eq [E1 ; E2][E / Y] = [E1[E / Y] ; E2[E / Y] ] .
    eq (E1 E2)[E / Y] = (E1[E / Y]) (E2[E / Y]) .
    eq { Vs }[E / Y] = { Vs[E / Y] } .
    eq sum(E1)[E / Y] = sum(E1[E / Y]) .
    eq sub(E1, E2)[E / Y] = sub(E1[E / Y], E2[E / Y]) .
    ceq (let [ X ; Y ] := E1 in E2)[E / Z] = let [ X ; Y ] := E1[E / Z] in (E2[E / Z])
        if not(X in (Z, varsOf(E))) /\
           not(Y in (Z, varsOf(E))) .
    ceq (let [ X ; Y ] := E1 in E2)[E / Z] = (let [ A ; Y ] := E1[A / X] in (E2[A / X]))[E / Z]
        if X in (Z, varsOf(E)) /\
           A := freshVar(Z, varsOf(E), X, Y, varsOf(E1), varsOf(E2)) .
    ceq (let [ X ; Y ] := E1 in E2)[E / Z] = (let [ X ; A ] := E1[A / Y] in (E2[A / Y]))[E / Z]
        if not(X in Z, varsOf(E)) /\
           Y in Z, varsOf(E) /\
           A := freshVar(Z, varsOf(E), X, Y, varsOf(E1), varsOf(E2)) .

    ceq (let [ X ] := E1 in E2)[E / Y] = let [ X ] := E1[E / Y] in (E2[E / Y])
        if not(X in Y, varsOf(E)) .
    ceq (let [ X ] := E1 in E2)[E / Y] = (let [ Z ] := E1[Z / X] in (E2[Z / X]))[E / Y]
        if X in Y, varsOf(E) /\
           Z := freshVar(X, Y, varsOf(E1), varsOf(E2), varsOf(E)) .

    eq (try { E1 } catch { E2 })[E / Y] = try { E1[E / Y] } catch { E2[E / Y] } .
    eq (assert E1 is Q in E2)[E / Y] = assert (E1[E / Y]) is Q in (E2[E / Y]) .

    eq groupWith(Q, F, E1, E2)[E / Y] = groupWith(Q, F[E / Y], E1[E / Y], E2[E / Y]) .
    eq label(E1)[E / Y] = label(E1[E / Y]) .
    eq copy(E1)[E / Y] = copy(E1[E / Y]) .

    op unpackSingleton : Qid Expr Expr -> Expr .
    eq unpackSingleton(X, { E }, E2) = E2[E / X] .
    eq unpackSingleton(X, E, E2) = fail [owise] .

    op applyLabels : Nat Multiset -> Multiset .
    eq applyLabels(N, mt) = mt .
    eq applyLabels(N, (V, Vs)) = [ id(N) ; V ], applyLabels(N + 1, Vs) .

    op _++_ : Val Val -> Val [comm assoc] .
    eq { Vs } ++ { Ws } = { Vs, Ws } .
    eq [ V ; W ] ++ [ V1 ; V2 ] = [ V ++ V1 ; W ++ V2 ] .
    eq zero ++ V = V .
    eq fail ++ V = fail .

    op calculateSum : MultisetVal -> Val .
    eq calculateSum(mt) = zero .
    eq calculateSum(V, Vs) = V ++ calculateSum(Vs) .

    op |_| : Expr -> Nat .
    eq |{ mt }| = 0 .
    eq |{ E, Vs }| = 1 + | { Vs } | .
    eq | [ E1 ; E2 ] | = 1 .
    eq | zero | = 0 .

    op compatQuant : TyQuant Expr -> Bool .
    eq compatQuant(*, E) = true .
    eq compatQuant(N, E) = N == | E | .
    eq compatQuant(oo, lambda X : Tau . E) = true .
    eq compatQuant(Q, E) = false [owise] .

    op groupSize : MultisetVal MultisetVal -> Val .
    eq groupSize(Vs, mt) = [[{mt}; {mt}]; [{Vs}; {mt}]] .
    eq groupSize(mt, Vs) = [[{mt}; {mt}]; [{mt}; {Vs}]] .
    eq groupSize((V1, Vs), (V2, Ws)) = [[{V1}; {V2}]; [{mt}; {mt}]] ++ groupSize(Vs, Ws) .

    op partitionByKey : Id MultisetVal -> Val .
    eq partitionByKey(K, mt) = [ {mt} ; {mt} ] .
    eq partitionByKey(K, ([K ; V], Rest)) = [{[K ; V]}; {mt}] ++ partitionByKey(K, Rest) .
    eq partitionByKey(K, ([K2 ; V], Rest)) = [{mt}; {[K2 ; V]}] ++ partitionByKey(K, Rest) [owise] .

    op fsts : Multiset -> Multiset .
    eq fsts(mt) = mt .
    eq fsts([E1 ; E2], Rest) = E1, fsts(Rest) .
    op snds : Multiset -> Multiset .
    eq snds(mt) = mt .
    eq snds([E1 ; E2], Rest) = E2, snds(Rest) .

    vars G1 G2 G3 G4 : Multiset .
    op runGroupWith : TyQuant Val MultisetVal MultisetVal -> Multiset .
    eq runGroupWith(Q, F, mt, mt) = mt .
    ceq runGroupWith(Q, F, mt, ([K ; E], Rest)) = (F [K ; [{mt}; {snds(Vs)}]]), runGroupWith(Q, F, mt, Ws)
        if [{Vs} ; {Ws}] := partitionByKey(K, ([K ; E], Rest)) .
    ceq runGroupWith(Q, F, ([K ; E], Vs), Ws) =
        if Taken2 == mt then
            (F [K ; [{snds(Taken1)}; {mt}]]), runGroupWith(Q, F, Rest1, Rest2)
        else
            (F [K ; [{snds(G1)}; {snds(G2)}]]), runGroupWith(Q, F, (G3, Rest1), (G4, Rest2))
        fi

        if [{Taken1} ; {Rest1}] := partitionByKey(K, ([K ; E], Vs)) /\
           [{Taken2} ; {Rest2}] := partitionByKey(K, Ws) /\
           [[{G1}; {G2}]; [{G3}; {G4}]] := groupSize(Taken1, Taken2) .

    op map : -> Val .
    eq map = lambda 'params : * nonasset unit .
        (let [ 'f ; 'xs ] := 'params in groupWith(*,
                     lambda 'input : * nonasset unit .
                        (let [ 'k ; 'rest ] := 'input in
                        let [ 'left ; 'right ] := 'rest in
                        let [ 'head ] := 'left in
                        ('f 'head)), label('xs), {mt})) .

    op unzipPair : -> Val .
    eq unzipPair = lambda 'pair : * nonasset unit . let [ 'x ; 'y ] := 'pair in [ { 'x } ; { 'y } ] .

    op unzip : -> Val .
    eq unzip = lambda 'xs : * nonasset unit . sum(map [ unzipPair ; 'xs ]) .

    --- op splitWith : -> Expr .
    --- eq splitWith = (lambda 'params : * nonasset unit . let [ 'f ; 'xs ] := 'params in sum(

    rl [Copy]: copy(E) => E .

    crl let [ X ; Y ] := V in E2 => E2[Left / X][Right / Y]
        if V => [ Left ; Right ] .
    crl let [ X ] := E1 in E2 => unpackSingleton(X, V, E2)
        if E1 => V .

    crl E1 E2 => E[V / X]
        if E1 => (lambda X : Tau . E) /\
           E2 => V .

    crl { Vs, E1, Ws } => { Vs, V, Ws }
        if E1 => V /\ V =/= E1 .

    rl { Vs, fail, Ws } => fail .

    crl label(E1) => { applyLabels(0, Vs) }
        if E1 => { Vs } .

    crl try { E1 } catch { E2 } => if E1 == fail then E2 else E fi
        if E1 => E .

    crl sum(E1) => calculateSum(Vs)
        if E1 => { Vs } .

    crl assert E1 is Q in E2 =>
        if compatQuant(Q, E) then
            E2
        else
            fail
        fi

        if E1 => E .

    crl groupWith(Q, F, E1, E2) => { runGroupWith(Q, (lambda X : Tau . E), Vs, Ws) }
        if F => (lambda X : Tau . E) /\
           E1 => { Vs } /\
           E2 => { Ws } .

    --- TODO: sub
endm

red [ { zero, zero } ; { zero, zero } ] .
red let [ 'x ; 'y ] := [ zero ; zero ] in zero .

red demote(* asset multiset (1 asset multiset (oo asset (1 nonasset unit x 1 asset unit)))) .

rew let [ 'x ; 'y ] := [ zero ; zero ] in 'x .

rew let [ 'x ] := { zero } in 'x .
rew let [ 'x ] := { zero, zero } in 'x .

rew { (let [ 'x ] := { zero, zero } in 'x) , zero } .
rew { (let [ 'x ] := { zero } in 'x) , zero } .

rew label({ zero, zero, zero }) .

rew try { fail } catch { {zero, zero} } .

rew sum({ { zero }, { zero, zero } }) .

rew groupWith(*, (lambda 'pair : * nonasset unit . 'pair), label({zero}), label({zero})) .

rew unzip label({ { zero }, { zero, zero }}) .

