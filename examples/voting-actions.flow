// Based on: https://github.com/WayneJz/COMP6452-19T1/blob/master/Assignment_1/contracts/message.sol

// Removed most code, keeping only the parts that are directly related to the "action" concept.
contract LunchVote {
    // These are "consumable" because we can self-destruct, and consume all of these resources.
    // That's fine, because these resources don't have any meaning outside of the contract, so there's no need to preserve them.
    type Voter is nonfungible consumable asset address
    source voterSource of Voter

    contractCreator : address

    authorizedVoters : set Voter

    event AuthorizedVoter(addr : address)

    on create():
        voterSource --- msg.sender --> authorizedVoters
        msg.sender ~~> contractCreator

    transaction authorizeVoter(newVoterAddress : address):
        only when contractCreator = msg.sender then
            // Actions: We name this flow "F" so we can refer to it later.
            // This version lets us attach multiple "actions" to F, which depend on the outcome of F
            // In this case, as there's only one flow in this transaction, there's not actually any need to name it.
            F: voterSource --- newVoterAddress --> authorizedVoters

            // Attach an "action" that occurs when the "trigger" activates.
            // Triggers only occur at the end of the transaction, providing protection from reentrancy
            //   in the way that Scilla does. The notable difference is that we allow checking the return value of contracts.
            //   Actions are otherwise processed in lexical order.

            // Syntax is currently:
            [action] TRIGGER: ACTION
            // It could be something like to emphasize that it doesn't happen when it is written.
            create/setup [action] TRIGGER : ACTION

            // Here, Err may contain more specific failure information, such as an error message
            on fail F with Err: revert("This address is already authorized! Do not re-authorize it.")
            // Alternate version with the "action" keyword.
            action on fail F with Err: revert("This address is already authorized! Do not re-authorize it.")

            // Events can also be handled via the action mechanism. Probably not really necessary; there shouldn't be
            //  any issues with having emit just look like it does in Solidity, but it does unify everything as an action.
            //  It also let's us easy trigger certain events "on fail"
            on success emit AuthorizedVoter(newVoterAddress)

            // This action isn't necessary for this transaction, but is the original motivation for this mechanism.
            // This type of external call is **required** by ERC-721, and also a couple other Ethereum standards and common patterns.
            // Obviously there's other kinds of external calls, but in my experience, this is sufficient for most contracts.
            on success F call newVoterAddress.receiveAuthorization()
                         returning resultCode such that resultCode = "SUCCESS"
            // The syntax for the above could omit the word "action" and only write the trigger.

            // Complete version below:
            F: voterSource --- newVoterAddress --> authorizedVoters
            handler [for] F {
            handler [for] {F} {
                on fail with Err:
                    revert("This address is already authorized! Do not re-authorize it.")
                on success:
                    emit AuthorizedVoter(newVoterAddress)
                    call newVoterAddress.receiveAuthorization()
                        returning resultCode such that resultCode = "SUCCESS"
            }

            // If you have multiple flows:
            F1: A --- x ---> B
            F2: C --- y ---> D

            // So we run "on success" if F1 AND F2 succeed
            // And we run "on fail" if F1 OR F2 fail.
            handler {F1, F2} {
                on fail with Err:
                    // Stuff

                on success:
                    // Stuff
            }

            // We **could** later add even more handlers if we want to handle other weird combinations of flows, but I don't think that's going to be very useful.
            // Note that you **cannot** flow in a handler.
            // If you wanted to do something like
            try
                A --- x --> B
            catch
                C --- y --> D

            // So that the second flow only happens if the first fails, you should instead
            // just check whatever condition you're actually interested in.
            // I don't think this will greatly impact usability, and in fact is probably easier to read
            // because the condition has to be specified, and you won't get unexpected failures causing the flow
            // For example, say you want to do the second flow only when there isn't enough money in A for the flow to occur
            // But the above implementation would also cause the money to be taken from C in the case that there's

            // This version does the same (in this particlar case)
            voterSource --- newVoterAddress --> authorizedVoters

            // A handler without any specified flows means that it's a handler for ALL flows in this transaction.
            handler {
                on fail with Err:
                    revert("This address is already authorized! Do not re-authorize it.")
                on success:
                    emit AuthorizedVoter(newVoterAddress)
                    call newVoterAddress.receiveAuthorization()
                        returning resultCode such that resultCode = "SUCCESS"
            }

            // This is also like a try-catch, but more "action-y". Is it though?
            do {
                voterSource --- newVoterAddress --> authorizedVoters
            } and handle {
                failure with Err:
                    revert("This address is already authorized! Do not re-authorize it.")

                success:
                    emit AuthorizedVoter(newVoterAddress)
                    call newVoterAddress.receiveAuthorization()
                        returning resultCode such that resultCode = "SUCCESS"
            }

            // A more typical looking approach:
            // Pros:
            // - Looks "normal"
            // Cons:
            // - More opportunity for reentrancy bugs.
            // - More complicated program structure (a transaction is just a list of actions/flows vs. having every construct that any other language would have)
            try {
                voterSource --- newVoterAddress --> authorizedVoters
            } catch (Err) {
                revert("This address is already authorized! Do not re-authorize it.")
            }
            emit AuthorizedVoter(newVoterAddress)
            if newVoterAddress.receiveAuthorization() != "SUCCESS" then
                revert();
}

