// Based on: https://github.com/pnalvarez/Meditrack-Solidity

contract Request{
    type Approver is nonfungible consumable asset address

    id : nat
    approved : bool
    voted : set Approver

    view isApproved() returns bool := approved

    transaction approve() returns (bool)
    transaction updateApprovers(newApprover : address)
}

contract ManagerRequest is Request {
    newUser : address
    approvers : set Approver

    event ApprovedBy(approver : address)
    event Approved(approveCounts : nat)
    event NewApprover(newApprover : address)

    view notApproved() returns bool := not approved

    on create(_id : nat, _newUser : address, _approvers : set address):
        id := _id
        newUser := _newUser
        Approver --[ _approvers ]-> approvers
        approved := false

    view getNewUser() returns address := newUser

    transaction approve() returns bool:
        only when notApproved()

        approvers --[ msg.sender ]-> voted

        approved := total voted >= total approvers
        on success:
            if approved then emit Approved(total voted)

        on success: emit ApprovedBy(msg.sender)

        return approved

    transaction updateApprovers(newApprover : address):
        Approver[newApprover] --> approvers
        on success: emit NewApprover(newApprover)
}

contract MedicineRequest is Request {
    medicineId : string
    name : string
    description : string
    value : nat
    validity : nat

    approvers : set Approver
    uint approveCounts;

    event ApprovedBy(approver : address)
    event Approved(medicineId : string)
    event NewApprover(newApprover : address)

    view notApproved() returns bool := not approved

    on create(_id : nat, _medicineId : string, _name : string, _description : string, uint _value, uint _validity, address[] _approvers):
        id := _id
        medicineId := _medicineId
        name := _name
        description := _description
        value := _value
        validity := _validity

        Approver --[ _approvers ]-> approvers
        approved := false

    view getMedicineName() returns string := name
    view getMedicineDescription() returns string := description
    view getMedicineValue() returns nat := value
    view getMedicineValidity() returns nat := validity
    view getMedicineId() returns string := medicineId

    transaction approve() returns bool:
        only when notApproved()

        approvers --[ msg.sender ]-> voted

        approved := total voted >= total approvers
        on success:
            if approved then emit Approved(total voted)

        on success: emit ApprovedBy(msg.sender)

        return approved

    transaction updateApprovers(newApprover : address):
        newApprover --> approvers
        on success: emit NewApprover(newApprover)
}

contract TransferRequest is Request {
    productId : string
    approver : option Approver
    approverAddr : address
    sender : address

    event TransferRequestCreated(productId : string, sender : address, approver : address)
    event Approved()
    event NewApprover(newApprover : address)

    view notApproved() returns bool := not approved

    on create(_id : nat, _approver : address, _productId : string, _sender : address):
        productId := _productId
        id := _id
        sender := _sender

        approverAddr := approver
        Approver[_approver] --> approver
        approved := false

        on success: emit TransferRequestCreated( _productId, _sender, _approver)

    view getProductId() returns string := productId
    view getApprover() returns address := approverAddr

    transaction approve() returns bool:
        only when notApproved()

        approver --[ msg.sender ]-> voted
        approved := true

        on success: emit Approved()

        return approved

    transaction updateApprovers(newApprover : address):
        newApprover --> approvers
        on success: emit NewApprover(newApprover)
}

contract UserRequest is Request {
    newUser : address
    func : string
    approvers : set Approver

    event ApprovedBy(approver : address)
    event Approved(approveCounts : nat)
    event NewApprover(newApprover : address)

    view notApproved() returns bool := not approved

    on create(_id : nat, _newUser : address, f : string, _approvers : set address):
        id := _id
        newUser := _newUser
        func := f

        Approver --[ _approvers ]-> approvers
        approved := false

    view getNewUser() returns address := newUser
    view getFunc() returns string := func

    transaction approve() returns bool:
        only when notApproved()

        approvers --[ msg.sender ]-> voted

        approved := total voted >= total approvers
        on success:
            if approved then emit Approved(total voted)
            emit ApprovedBy(msg.sender)

        return approved

    transaction updateApprovers(newApprover : address):
        newApprover --> approvers
        on success: emit NewApprover(newApprover)
}

contract SupplyChain {
    type Receive is {
        uuid : string,
        id : string,
        timestamp : nat,
        from : address,
        to : address
    }

    type Person is nonfungible asset address
    type Function is Nothing | Producer | Stock | Transport | SurgicalCenter | Seller | Buyer
    functions : linking Function <=> {Person}

    type Wallet is asset {
        isManager : bool,
        medicines : set string,
        products : set string, // TODO: Maybe this should be: set Product
        creationTime : nat
    }

    type Medicine is nonfungible asset {
        name : string,
        description : string,
        initialized : bool,
        value : nat,
        validity : nat
    }

    type PathRecord is {
        addr : address,
        timestamp : nat
    }

    type Product is asset {
        id : string,
        owner : address,
        creationTime : nat
    }

    type Sinister is {
        title : string,
        description : string,
        envolvedProduct : string,
        responsible : address,
        timestamp : nat
    }

    managers : set address

    // NOTE: The original contract included a `productExist` variable storing which keys exist,
    //          as well lists of all the medicine names, product names, and wallets.
    // This suggests that generating and managing these extra variables is actually **not** a waste of resources.
    medicines : map string => Medicine
    wallets : map address => Wallet

    products : map string => Product
    productPath : map string => list PathRecord
    destroyedProducts : map string => Product

    begin : nat

    receives : map address => map string => Receive
    sinisters : map address => map string => Sinister

    isInAlfaCenter : set address
    stringToFunc : map string => Function

    productWasDeleted : set string

    managerRequests : map nat => ManagerRequest
    transferRequests : map nat => TransferRequest
    userRequests : map nat => UserRequest
    medicineRequests : map nat => MedicineRequest

    event medicineCreated(id : string)
    event medicineTransfered(uuid : string, id : string, from : address, to : address)
    event productGenerated(by : address, uuid : string, id : string)
    event changeSent(to : address, change : nat)
    event medicineBought(by : address, uuid : string)
    event FunctionDesignated(to : address, f : Function)
    event ProductOutOfValidity(uuid : string, id : string, time : nat)
    event NewSinister(title : string, uuid : string, responsible : address)
    event PathIncremented(uuid : string, id : string, adr : address, timestamp : nat)
    event DiscardedProduct(uuid : string, lastowner : address, timestamp : nat)
    event ThrowProductAway(uuid : string, by : address, timestamp : nat)
    event NewRequest()
    event NewManagerApproved(newManager : address)

    view isManager() returns bool := wallets[msg.sender].isManager
    view hasFunction(f : Function) returns bool := msg.sender in functions[f]
    view productExists(uuid : string) returns bool := uuid in products
    view isProductOwner(a : address, uuid : string) returns bool := uuid in wallets[a].products
    view personExists(a : address) returns bool := a in wallets
    view validProduct(uuid : string) returns bool :=
        let product := products[uuid] in
            (now - product.creationTime) < medicines[product.id].validity

    view walletExists(adr : address) returns bool := adr in wallets

    view isValidTransfer(_from : address, _to : address) :=
        (key of _from in functions, key of _to in functions) in
            {
                (Producer, Transport),
                (Transport, Stock),
                (Stock, Stock),
                (Stock, SurgicalCenter),
                (Stock, Seller)
            }

    on create():
        msg.sender --> managers
        begin := now
        Wallet(true, now) --> wallets[msg.sender]
        msg.sender --> functions[Producer]

        Nothing --> stringToFunction["Nothing"]
        Producer --> stringToFunction["Productor"]
        Stock --> stringToFunction["Stock"]
        Transport --> stringToFunction["Transport"]
        SurgicalCenter --> stringToFunction["SurgicalCenter"]
        Seller --> stringToFunction["Seller"]
        Buyer --> stringToFunction["Buyer"]

    private transaction designateFunction(wallet : address, func : string):
        functions[owner of wallet in functions] --[ wallet ]-> functions[stringToFunction[func]]
        on success: emit FunctionDesignated(wallet, stringToFunction[func])

    private transaction transferOperation(_from : address, uuid : string, _to : address) returns Receive:
        var id : string := products[uuid].id

        wallets[_from].products --[ uuid ]-> wallets[_to].products
        wallets[_from].medicines --[ id ]-> wallets[_to].medicines

        products[uuid].owner := _to

        Receive(uuid, id, now, _from, _to) --> receives[_to][uuid]

        on success:
            call incrementPath(uuid, _to)
            emit medicineTransfered(uuid, id, _from, _to);

        return receives[_to][uuid]

   function sendMedicine(string uuid)private{

        string memory id = products[uuid].id;

       wallets[msg.sender].products[uuid] = false;
       wallets[msg.sender].medicines[id] -= 1;
   }

    private transaction sendChange() returns nat:
        var oldBalance : nat := this.balance
        this.balance --> msg.sender.transfer

        on success:
            emit changeSent(msg.sender, balance);

        return balance

  function searchProductIndex(string uuid)public view returns(int){

      for(int i = 0; i < int(allProducts.length); i++){
        uint ui = uint(i);

        string memory product = allProducts[ui];

        if(compareStrings(product,uuid)){
          return i;
        }
      }
      return -1;
  }

    private transaction incrementPath(uuid : string, adr : address):
        only when productExists(uuid)

        PathRecord(adr, time) --> productPath[uuid]

        on success: emit PathIncremented(uuid, products[uuid].id, adr, time);

    private transaction discardProduct(uuid : string):
        only when productExists(uuid)

        consume products[uuid].id from wallets[products[uuid].owner].medicines
        consume uuid from wallets[owner].products[uuid]

        products[uuid].owner := 0x0
        products[uuid] --> destroyedProducts[uuid]

        on success: emit DiscardedProduct(uuid, owner, now)

    private transaction medicineCreate(id : string, _name : string, _description : string, _value : nat, _validity : nat):
       Medicine(_name, _description, true, _value, _validity) --> medicines[id]
       on success: emit medicineCreated(id)

    private transaction createWallet(adr : address, f : string):
        Wallet(false, now) --> wallets[adr]
        adr --> functions[stringToFunction[f]]

    transaction medicineGenerate(uuid : string, id : string):
        only when hasFunction(Producer) and uuid not in destroyedProducts

        Product(id, msg.sender, true, time) --> products[uuid]
        uuid --> wallets[msg.sender].products
        id --> wallets[msg.sender].medicines

        on success:
            emit productGenerated(msg.sender, uuid, id)
            call incrementPath(uuid, msg.sender)

    transaction buyMedicine(_from : address, uuid : string, value : ether) returns nat:
        only when hasFunction(Buyer) and
                  value >= medicines[products[uuid].id].value and
                  validProduct(uuid) and
                  _from in functions[Seller]

        uint change = sendChange();
        transferOperation(from, uuid, msg.sender);

        on success:
            emit medicineBought(msg.sender, uuid)
            call transferOperation(_from, uuid, msg.sender)

        return change

    // Invalidates all products that have expired
    transaction checkValidity():
        products --[ any (uuid => prod) such that not validProduct(uuid) ]-> invalidProducts
      for(uint i = 0; i < allProducts.length; i++){

          Product storage product = products[allProducts[i]];

           if(product.isValid){
               uint timestamp = now - product.creationTime;

               if(timestamp >= medicines[product.id].validity){
                    product.isValid = false;
                    emit ProductOutOfValidity(allProducts[i], product.id, timestamp - medicines[product.id].validity);
               }
           }
      }
  }

   only(Function.Buyer)
   productExists(uuid) productOwner(from, uuid) checkTime
   validProduct(uuid)
   returns(uint){

       require(msg.value >= medicines[products[uuid].id].value, "Not enough balance");
       require(wallets[from].func == Function.Seller, "Only seller can sell");

       uint change = sendChange();
       transferOperation(from, uuid, msg.sender);

       return change;
   }

    transaction addNewMedicineRequest(id : string, name : string, description : string, value : nat, validity : nat):
        only when isManager() and id not in medicines

        new MedicineRequest(medicineRequests.length, id, name, description, value, validity, managers) --> medicineRequests[medicineRequests.length]

        on success: emit NewRequest()

    transaction approveNewMedicineRequest(uint id)public onlyManager checkTime:
        only when isManager()

        on success:
            call medicineRequests[id].approve()

       require(medicineRequests.length > id, "Request invalid");

       medicineRequests[id].approve();

       if(medicineRequests[id].isApproved()){

           string memory medicineId = medicineRequests[id].getMedicineId();
           string memory name = medicineRequests[id].getMedicineName();
           string memory description = medicineRequests[id].getMedicineDescription();
           uint value = medicineRequests[id].getMedicineValue();
           uint validity = medicineRequests[id].getMedicineValidity();

           medicineCreate(medicineId, name, description, value, validity);
       }
   }

    transaction addNewUserRequest(adr : address, f : string):
        only when isManager() and not walletExists(adr)

        new UserRequest(total userRequests, adr, f, managers) --> userRequests

        on success: emit NewRequest()

   function approveNewUserRequest(uint id)public checkTime{
       require(userRequests.length > id, "Request invalid");

       userRequests[id].approve();

       if(userRequests[id].isApproved()){

           address newUser = userRequests[id].getNewUser();
           string memory func = userRequests[id].getFunc();

           createWallet(newUser, func);
       }
   }

   function addNewManagerRequest(address newManager)public
   onlyManager
   personExists(newManager)
   checkTime {
       require(!wallets[newManager].isManager, "he is already a manager");

       ManagerRequest request = new ManagerRequest(managerRequests.length, newManager, managers);
       managerRequests.push(request);

       emit NewRequest();
   }

   function approveNewManagerRequest(uint id)public checkTime{
       require(managerRequests.length > id, "Request invalid");

       managerRequests[id].approve();

       if(managerRequests[id].isApproved()){

           address newManager = managerRequests[id].getNewUser();
           managers.push(newManager);

           for(uint i = 0; i < managerRequests.length; i++){
               if(!managerRequests[i].isApproved()){
                   managerRequests[i].updateApprovers(newManager);
               }
           }

           emit NewManagerApproved(newManager);
       }
   }

   function newTransferRequest(string uuid, address to)public
   validProduct(uuid)
   productOwner(msg.sender, uuid)
   supplychainRule(msg.sender, to)
   checkTime{

    only when isValidTransfer(msg.sender, to)

       TransferRequest request = new TransferRequest(transferRequests.length, to, uuid, msg.sender);
       transferRequests.push(request);

       emit NewRequest();
   }

   function approveTransferRequest(uint id)public checkTime{
       require(transferRequests.length > id, "Request invalid");

       transferRequests[id].approve();

       string memory uuid = transferRequests[id].getProductId();
       address to = transferRequests[id].getApprover();

       transferOperation(msg.sender, uuid, to);
   }

   function notifySinister(string _title, string _description, string _product)public checkTime
   productExists(_product) productOwner(msg.sender, _product) returns(Sinister){

       uint _timestamp = now;
       Sinister memory sinister = Sinister(_title,_description,_product,msg.sender,_timestamp);
       sinisters[msg.sender].push(sinister);

       discardProduct(_product);

       emit NewSinister(_title, _product, msg.sender);

       return sinister;
   }

    transaction throwAway(uuid : string):
        only when isProductOwner(msg.sender, uuid)

        on success:
            call discardProduct(uuid)
            emit ThrowProductAway(uuid, msg.sender, now)

    function throwAway(string uuid)public checkTime productOwner(msg.sender, uuid){
        discardProduct(uuid);
        uint timestamp = now;

    }

    view getReceive(uuid : string) returns Receive := receives[msg.sender][uuid]

   function trackProduct(string uuid, uint timestamp)public view
    productExists(uuid) returns(address){
      uint currentTime = now;

      require(timestamp <= currentTime, "Please enter a valid time");

      uint[] memory timestamps = products[uuid].timestamps;

      for(uint i = 0; i < timestamps.length - 1; i++){
        if(timestamps[i] <= timestamp && timestamp <= timestamps[i+1]){
          return products[uuid].path[i];
        }
      }
      return products[uuid].owner;
   }

   function getMedicineName(string id)public view returns(string){
     return medicines[id].name;
   }
   function getMedicineDescription(string id)public view returns(string){
     return medicines[id].description;
   }
   function getMedicineValue(string id)public view returns(uint){
     return medicines[id].value;
   }
   function getMedicineValidity(string id)public view returns(uint){
     return medicines[id].validity;
   }

   function getWalletMedicineQtd(address adr, string id)public view returns(uint){
      return wallets[adr].medicines[id];
   }

   function getWalletFunction(address adr)public view returns(string){

     if(wallets[adr].func == Function.Productor){
       return "Productor";
     }
     else if(wallets[adr].func == Function.Stock){
       return "Stock";
     }
     else if(wallets[adr].func == Function.Transport){
       return "Transport";
     }
     else if(wallets[adr].func == Function.CirurgicCenter){
       return "Cirurgic center";
     }
     else if(wallets[adr].func == Function.Nothing){
       return "Nothing";
     }
     else if(wallets[adr].func == Function.Seller){
       return "Seller";
     }
     else{
       return "Buyer";
     }
   }
   function walletHasProduct(address adr, string uuid)public view returns(bool){
      return wallets[adr].products[uuid];
   }
   function getWalletCreationTime(address adr)public view returns(uint){
       return wallets[adr].creationTime;
   }

   function getProductExist(string uuid)public view returns(bool){
     return productExist[uuid];
   }

   function getProductId(string uuid)public view returns(string){
     return products[uuid].id;
   }
   function getProductOwner(string uuid)public view returns(address){
     return products[uuid].owner;
   }
   function getProductValid(string uuid)public view returns(bool){
     return products[uuid].isValid;
   }
   function getProductCreationTime(string uuid)public view returns(uint){
     return products[uuid].creationTime;
   }
   function getProductCreator(string uuid)public view returns(address){
       return products[uuid].path[0];
   }
   function getTimestamp(string uuid, uint index)public view returns(uint){
       return products[uuid].timestamps[index];
   }

   function getReceiveProduct(uint index, address adr)public view returns(string){
     return receives[adr][index].uuid;
   }
   function getReceiveMedicine(uint index, address adr)public view returns(string){
     return receives[adr][index].id;
   }
   function getReceiveTimestamp(uint index, address adr)public view returns(uint){
     return receives[adr][index].timestamp;
   }
   function getReceiveFrom(uint index, address adr)public view returns(address){
     return receives[adr][index].from;
   }
   function getReceiveTo(uint index, address adr)public view returns(address){
     return receives[adr][index].to;
   }
   function getReceivesQtd(address adr)public view returns(uint){
       return receives[adr].length;
   }

   function getSinisterTitle(uint index, address adr)public view returns(string){
        return sinisters[adr][index].title;
   }
   function getSinisterDescription(uint index, address adr)public view returns(string){
        return sinisters[adr][index].description;
   }
   function getSinisterEnvolvedProduct(uint index, address adr)public view returns(string){
        return sinisters[adr][index].envolvedProduct;
   }
   function getSinisterResponsible(uint index, address adr)public view returns(address){
        return sinisters[adr][index].responsible;
   }
   function getSinisterTimestamp(uint index, address adr)public view returns(uint){
        return sinisters[adr][index].timestamp;
   }
   function getSinistersQtd(address adr)public view returns(uint){
       return sinisters[adr].length;
   }
   function getBalanceof(address adr)public view returns(uint){
     return adr.balance;
   }

   function productStillExist(string uuid)public view returns(bool){

      int index = searchProductIndex(uuid);

      return index >= 0;

   }

   function getMedicineNamesTotal()public view returns(uint){
    return medicineNames.length;
}
  function getAllProductsTotal()public view returns(uint){
    return allProducts.length;
}
  function getAllWalletsTotal()public view returns(uint){
      return allWallets.length;
  }

}

