\documentclass[nonacm, dvipsnames, sigconf]{acmart}

\usepackage{listings}
\usepackage{hyperref}
\usepackage{tikz-cd}
% \usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bm}
\usepackage{listings}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{float}
\usepackage{subcaption}
\usepackage{xcolor}
\usepackage[safe]{tipa}
\usepackage[inline]{enumitem}

%% \BibTeX command to typeset BibTeX logo in the docs
% \AtBeginDocument{%
%   \providecommand\BibTeX{{%
%     \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
% \setcopyright{acmcopyright}
% \copyrightyear{2018}
% \acmYear{2018}
% \acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
% \acmConference[Woodstock '18]{Woodstock '18: ACM Symposium on Neural
%   Gaze Detection}{June 03--05, 2018}{Woodstock, NY}
% \acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%   June 03--05, 2018, Woodstock, NY}
% \acmPrice{15.00}
% \acmISBN{978-1-4503-XXXX-X/18/06}

%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

\input{LaTeX/macros.tex}
\input{solidity-latex-highlighting/solidity-highlighting.tex}
\input{flow-highlighting.tex}
\input{macros.tex}

\settopmatter{printfolios=true}

\begin{document}

%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{\langName: A DSL for Safe Blockchain \AssetTxt{}s}

%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Reed Oei}
\affiliation{%
    \institution{University of Illinois}
  % \city{Urbana}
  % \country{USA}
}
\email{reedoei2@illinois.edu}

%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Trovato and Tobin, et al.}

%% The abstract is a short summary of the work to be presented in the
%% article.
% \begin{abstract}
%     Abstract.
% \end{abstract}

%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
% \begin{CCSXML}
% <ccs2012>
%  <concept>
%   <concept_id>10010520.10010553.10010562</concept_id>
%   <concept_desc>Computer systems organization~Embedded systems</concept_desc>
%   <concept_significance>500</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010575.10010755</concept_id>
%   <concept_desc>Computer systems organization~Redundancy</concept_desc>
%   <concept_significance>300</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010553.10010554</concept_id>
%   <concept_desc>Computer systems organization~Robotics</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10003033.10003083.10003095</concept_id>
%   <concept_desc>Networks~Network reliability</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Computer systems organization~Embedded systems}
% \ccsdesc[300]{Computer systems organization~Redundancy}
% \ccsdesc{Computer systems organization~Robotics}
% \ccsdesc[100]{Networks~Network reliability}

% %% Keywords. The author(s) should pick words that accurately describe
% %% the work being presented. Separate the keywords with commas.
% \keywords{datasets, neural networks, gaze detection, text tagging}

%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

Blockchains are increasingly used as platforms for applications called \emph{smart contracts}, which automatically manage transactions in an unbiased, mutually agreed-upon way.
Commonly proposed and implemented applications of smart contracts include supply chain management~\cite{SupplyChainUse}, healthcare~\cite{HealthcareUse}, \emph{token contracts}, a contract implementing a \emph{token standard}, such as ERC-20~\cite{erc20}, voting, crowdfunding, auctions, and more~\cite{Elsden18:Making}.
Smart contracts often manage \emph{digital assets}, such as cryptocurrencies, or, depending on the application, bids in an auction, votes in an election, and so on.
Token contracts are extremely common on Ethereum---about 73\% of high-activity contracts are token contracts~\cite{OlivaEtAl2019}.
% On the Ethereum blockchain~\cite{wood2014ethereum}, there are many token standards, including ERC-20, ERC-721, ERC-777, ERC-1155~\cite{erc20,erc721,erc777,erc1155}.
Smart contracts cannot be patched after being deployed, even if a security vulnerability is discovered.
% Developers must carefully review contracts, and some use an independent auditing service to help with this process.
% Despite this extra care, discoveries of vulnerabilities still occur regularly, often costing large amounts of money.
% Vulnerabilities still occur regularly, often costing large amounts of money.
% The well-known DAO attack~\cite{DAO} caused the loss of over 40 million dollars.
Some estimates suggest that as much as 46\% of smart contracts may have some vulnerability~\cite{luuOyente}.

\langName (\langNamePronounce) is a new programming language we are designing around a new abstraction, a \emph{flow}, representing an atomic transfer operation, which is useful in smart contracts managing digital \assetTxt{}s.
Flows allow the encoding of semantic information about the flow of \assetTxt{}s into the code.
The \langName language will also provide features to mark types as \emph{\assetTxt{}s}, with various \emph{modifiers} to control their use, which combine with flows to make some classes of bugs impossible.
Additionally, typical smart contracts are more \textbf{concise} in \langName because it handles common patterns and pitfalls automatically.
Solidity, the most commonly-used smart contract language on the Ethereum blockchain~\cite{EthereumForDevs}, does not provide analogous support for managing \assetTxt{}s.

There are also many newly-proposed blockchain languages, such as Flint, Move, Nomos, Obsidian, and Scilla~\cite{schrans2018flint, blackshear2019move, das2019nomos, coblenz2019obsidian, sergey2019scilla}.
Scilla and Move are intermediate-level languages, whereas \langName is a high-level language.
Obsidian, Move, Nomos, and Flint use linear or affine types to manage \assetTxt{}s, similarly to how \langName uses \emph{type quantities}.
% Type quantities provide a more precise analysis of the behavior of a program than linear types.
None of the these languages have flows or provide support for all the modifiers that \langName does.

% \langName (\langNamePronounce) is a new programming language we are designing around a new abstraction, called a \emph{flow}, representing an atomic transfer operation, which is widely applicable to smart contracts managing digital \assetTxt{}s.
% It will also provide features to mark certain values as \emph{\assetTxt{}s}, with various \emph{modifiers} to control their use, which combine with flows to make certain classes of bugs impossible.
% Solidity, the most commonly-used language for writing smart contracts on the Ethereum blockchain~\cite{EthereumForDevs}, does not make any effort to provide analogous support for managing \assetTxt{}s.

% \paragraph{Contributions}

% We make the following contributions with \langName.
% \begin{itemize}
%     \item \textbf{Flow abstraction}: \langName uses a new abstraction called a \emph{flow} to encode semantic information about the flow of \assetTxt{}s into the code.
%     \item \textbf{Safety guarantees}: \langName ensures that \assetTxt{}s are properly managed; eliminating reuse, \assetTxt-loss, and duplication bugs through the use of the flow abstraction and a type system tracking \emph{type quantities}.
%     \item \textbf{Conciseness}: \langName makes writing typical smart contracts more concise by handling common patterns and pitfalls automatically.
% \end{itemize}

% \reed{Optimizations? Need an implementation to evaluate.}
%     ALso, Some of the Solidity contracts are actually inefficient because:
%     They use lots of modifiers which repeat checks (see reference implementation of ERC-721).
%     They tend to use arrays to represent sets.
%  We can evaluate this by profiling or a simple opcode count (which is not only a proxy for performance, but also means that deploying the contract will be cheaper).

\section{Language}\label{sec:lang}
A \langName program is made of \emph{contracts}, each containing \emph{fields}, \emph{types}, and \emph{functions}.
Each contract instance in \langName represents a contract on the blockchain, and the fields provide persistent storage.
% Type declarations allow annotating values with modifiers, such as $\asset$.
% We distinguish between three types of function: \emph{transactions}, \emph{views}, and \emph{transformers}.
% Transactions and views are both \emph{methods}, which may access the fields of a contract; a transaction can read \textbf{and} write fields, whereas a view may only read fields.
% A transformer is a \textbf{pure} function, which is not part of any contract: it may contain flows and other statements, and it may mutate \textbf{local} state, but it cannot mutate the state of any contract.
Figure~\ref{fig:erc20-transfer-flow} shows a simple contract declaring a type, a field, and a transaction, which implements the core functionality of ERC-20's \lstinline{transfer} function.
ERC-20 is a standard for smart contracts that manage \textbf{fungible} tokens, and provides a bare-bones interface for this purpose.
\begin{figure}[ht]
    \centering
    \lstinputlisting[language=flow]{splash20-examples/erc20-transfer.flow}
    \caption{A contract with a simple \lstinline{transfer} function in \langName, which transfers \lstinline{amount} tokens from the sender's account to the destination account.
It is implemented with a single flow, which automatically checks all the preconditions to ensure the transfer is valid.}
    \label{fig:erc20-transfer-flow}
\end{figure}

% \subsection{Flows}
\langName is built around the concept of a \emph{flow}. %, an atomic, state-changing operation describing the transfer of values.
% Each flow has a \emph{source} and a \emph{destination}; they may optionally have a \emph{selector} or a \emph{transformer}, which default to $\everything$ and the identity transformer, respectively.
% The source of a flow \emph{provides} values, the destination of the flow \emph{accepts} these values, and the selector describes which subpart of the value(s) in the source should be transferred to the destination.
% The source and destination of a flow are \emph{storages}, which are either variables or one of the special storages $\newc~t$ or $\consume$.
% A selector is a function that takes as input the current value of the storage, and outputs the value(s) to select.
% Selectors act can be used like a filter in functional programming, or like a \lstinline{WHERE} in SQL.
% Using a transformer in a flow is like mapping a function over the collection of values being flowed.
% Using \reed{the more declarative, \emph{flow-based}; don't name other approach} a \emph{flow-based} approach provides the several advantages over the typical \emph{assignment-based} approach most languages use (e.g., incrementing, then decrementing):
Using the more declarative, \emph{flow-based} approach provides the following advantages:
\begin{itemize}
    \item \textbf{Precondition checking}: \langName automatically checks that a flow is valid; e.g., a flow of money would fail if there is not enough in the source, or if there is too much in the destination (e.g., due to overflow).
        % Flows can also fail for other reasons: a developer may specify that a certain flow must send all \assetTxt{}s matching a predicate, but in addition specify an expected \emph{quantity} that must be selected: any number, exactly one, or at least one.
    \item \textbf{Data-flow tracking}: We hypothesize that flows provide a clearer way of specifying how resources flow in the code itself, which may be less apparent using other approaches, especially in complicated contracts. %such as those involving transfer fees.
        Additionally, developers must explicitly mark when \assetTxt{}s are \emph{consumed}, and only assets marked as \flowinline{consumable} may be consumed. % , which we hypothesize leads to fewer accidental asset loss bugs.
    \item \textbf{Error messages}: When a flow fails, \langName provides automatic, descriptive error messages, such as
\begin{lstlisting}
"Cannot flow '<amount>' Token from account[<src>] to account[<dst>]:
    source only has <balance> Token."
\end{lstlisting}
        Flows enable these messages by encoding all the necessary information into the program.%, instead of using low-level operations like increment and decrement.
\end{itemize}

% \subsection{Type Quantities}
Each variable in \langName has a \emph{type quantity}, approximating the number of values in the variable, which is one of: $\emptyq$, $\any$, $\exactlyone$, $\nonempty$, $\every$ (``$\exactlyone$'' means ``exactly one'').
Only $\emptyq$ \assetTxt variables may be dropped.
Type quantities are inferred if omitted.
Type quantities provide the benefits of \emph{linear types}, but give a more precise analysis of the flow of values in a program.

\emph{Modifiers} can be used to place constraints on how values are managed: \flowinline{asset}, \flowinline{fungible}, \flowinline{unique}, \flowinline{immutable}, and \flowinline{consumable}.
A \flowinline{asset} is a value that must not be reused or accidentally lost.
A \flowinline{fungible} value represents a quantity which can be \textbf{merged}, and it is \textbf{not} \flowinline{unique}.
A \flowinline{unique} value only exists in at most one variable; it must be \flowinline{immutable} and an \flowinline{asset} to ensure it is not duplicated.
A \flowinline{immutable} value cannot be changed; in particular, it cannot be the source or destination of a flow.
A \flowinline{consumable} value is an \flowinline{asset} that it is sometimes appropriate to dispose of, done via the \flowinline{consume} construct, documenting that the disposal is intentional.
For example, ERC-20 tokens are \flowinline{fungible}, while ERC-721 tokens are \flowinline{unique} and \flowinline{immutable}.

\langName has transactional semantics: a sequence of flows will either all succeed, or, if a single flow fails, the rest will fail as well.
If a sequence of flows fails, the error ``bubbles up'', like an exception, until it either: a) reaches the top level, and the entire transaction fails; or b) reaches a \flowinline{catch}, and then only the changes made in the corresponding \flowinline{try} block will be reverted, and the code in the \flowinline{catch} block will be executed.

\section{Examples}
The complete Solidity and \langName code is in our repository~\cite{psamatheRepo}.
% \begin{figure*}
%     \centering
%     \begin{subfigure}[t]{0.49\textwidth}
%         \centering
%         \lstinputlisting[language=Solidity]{splash20-examples/erc721.sol}
%         \caption{A Solidity implementation of ERC-721's \lstinline{transferFrom}.}
%         \label{fig:erc721-impl-sol}
%     \end{subfigure}%
%     \hfill
%     \begin{subfigure}[t]{0.49\textwidth}
%         \centering
%         \lstinputlisting[language=flow]{splash20-examples/erc721.flow}
%         \caption{\langName implementation of ERC-721's \lstinline{transferFrom}.}
%         \label{fig:erc721-impl-flow}
%     \end{subfigure}
%     \caption{Implementation of ERC-721's \lstinline{transferFrom} function, which sends a specific token from the \lstinline{src} account to the \lstinline{dst} account.
%         It also must clear the approval of the token, if any.}
%     \label{fig:erc721-impl}
% \end{figure*}
% \begin{figure*}[ht]
%     \centering
%     \begin{subfigure}[t]{0.49\textwidth}
%         \centering
%         \lstinputlisting[language=Solidity]{splash20-examples/voting.sol}
%         \caption{Solidity implementation of the core voting functions~\cite{solidityByExample}.}
%         \label{fig:voting-impl-sol}
%     \end{subfigure}%
%     \hfill
%     \begin{subfigure}[t]{0.49\textwidth}
%         \centering
%         \lstinputlisting[language=flow]{splash20-examples/voting.flow}
%         \caption{\langName implementation of the core voting functions.}
%         \label{fig:voting-impl-flow}
%     \end{subfigure}
%     \caption{A voting contract with a set of proposals, for which each user must first be given permission to vote by the chairperson, assigned in the constructor of the contract (not shown).
%     Each user can vote exactly once for exactly one proposal.
%     The proposal with the most votes wins.}
%     \label{fig:voting-impl}
% \end{figure*}

\subsection{ERC-20}\label{sec:erc20-impl}
\begin{figure}
    \centering
    \lstinputlisting[language=Solidity]{splash20-examples/erc20-transfer.sol}
    \caption{An implementation of ERC-20's \lstinline{transfer} function in Solidity from one of the reference implementations~\cite{erc20Consensys}.
        All preconditions are checked manually.
        Note that we must include the \lstinline{SafeMath} library (not shown), which checks for underflow/overflow, to use the \lstinline{add} and \lstinline{sub} functions.}
    \label{fig:erc20-transfer-sol}
\end{figure}
Figure~\ref{fig:erc20-transfer-sol} shows a Solidity implementation of the ERC-20 function \lstinline{transfer} (cf. Figure~\ref{fig:erc20-transfer-flow}).
Each ERC-20 contract manages the ``bank accounts'' for its own tokens, keeping track of how many tokens each user has; users are represented by addresses.
This example shows the advantages of flows in precondition checking, data-flow tracking, and error messages.
In this case, the sender's balance must be at least as large as \flowinline{amount}, and the destination's balance must not overflow when it receives the tokens.
Code checking these two conditions is automatically inserted, ensuring that the checks are not forgotten.

\subsection{Voting}\label{sec:voting-impl}
\begin{figure}
    \centering
    \lstinputlisting[language=Solidity]{splash20-examples/voting.sol}
    \caption{A simple voting contract in Solidity.}
    \label{fig:voting-impl-sol}
\end{figure}%
\begin{figure}
    \centering
    \lstinputlisting[language=flow]{splash20-examples/voting.flow}
    \caption{A simple voting contract in \langName.}
    \label{fig:voting-impl-flow}
\end{figure}
One proposed use for blockchains is for voting~\cite{Elsden18:Making}.
Figures~\ref{fig:voting-impl-sol} and~\ref{fig:voting-impl-flow} show the core of an implementation of a voting contract in Solidity and \langName, respectively, based on the Solidity by Example tutorial~\cite{solidityByExample}.
An instance of the contract has several proposals, and each user must be given permission to vote by the chairperson, assigned in the constructor of the contract (not shown).
Each user can vote exactly once for exactly one proposal.
The proposal with the most votes wins.

This example shows \langName is suited for a range of applications.
It also shows that some uses of the $\unique$ modifier; in this contract, $\unique$ ensures that each user, represented by an \lstinline{address}, can be given permission to vote at most once, while the use of $\asset$ ensures that votes are not lost or double-counted.
% The Solidity implementation is also more verbose than the \langName implementation because it must work around the limitations of the mapping structure.
% In this example, the \lstinline{weight} and \lstinline{voted} members of the \lstinline{Voter} struct exist so that the contract can tell whether a voter has the default values, was authorized to vote, or has already voted.

\section{Conclusion and Future Work}

We have presented the \langName langauge for writing safer smart contracts.
\langName uses the new flow abstraction, \assetTxt{}s, and modifiers to provide safety guarantees for smart contracts.
We showed several examples of smart contracts in both Solidity and \langName, showing that \langName is capable of expressing common smart contract functionality in a concise manner, while retaining key safety properties.

In the future, we plan to implement the \langName language, and prove its safety properties.
We also hope to study the benefits of the language via case studies, performance evaluation, and the application of flows to other domains.
Finally, we would also like to conduct a user study to evaluate the usability of the flow abstraction and the design of the language, and to compare it to Solidity.

%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{biblio}

\end{document}
\endinput

