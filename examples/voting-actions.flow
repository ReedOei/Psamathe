// Based on: https://github.com/WayneJz/COMP6452-19T1/blob/master/Assignment_1/contracts/message.sol

// Removed most code, keeping only the parts that are directly related to the "action" concept.
contract LunchVote {
    // These are "consumable" because we can self-destruct, and consume all of these resources.
    // That's fine, because these resources don't have any meaning outside of the contract, so there's no need to preserve them.
    type Voter is nonfungible consumable asset address
    source voterSource of Voter

    contractCreator : address

    authorizedVoters : set Voter

    event AuthorizedVoter(addr : address)

    on create():
        voterSource --- msg.sender --> authorizedVoters
        msg.sender ~~> contractCreator

    // Basic version with names, without `handle`:
    transaction authorizeVoter(newVoterAddress : address):
        only when contractCreator = msg.sender then
            F: voterSource --- newVoterAddress --> authorizedVoters
            on fail F with Err:
                revert("This address is already authorized! Do not re-authorize it.")
            on success F:
                emit AuthorizedVoter(newVoterAddress)
                call newVoterAddress.receiveAuthorization()
                    returning resultCode such that resultCode = "SUCCESS"

    // Version without flow names, without `handle`:
    transaction authorizeVoter(newVoterAddress : address):
        only when contractCreator = msg.sender then
            voterSource --- newVoterAddress --> authorizedVoters
            on fail with Err:
                revert("This address is already authorized! Do not re-authorize it.")
            on success:
                emit AuthorizedVoter(newVoterAddress)
                call newVoterAddress.receiveAuthorization()
                    returning resultCode such that resultCode = "SUCCESS"

    // Basic version with handle:
    transaction authorizeVoter(newVoterAddress : address):
        only when contractCreator = msg.sender then
            F: voterSource --- newVoterAddress --> authorizedVoters
            handle F:
                on fail with Err:
                    revert("This address is already authorized! Do not re-authorize it.")
                on success:
                    emit AuthorizedVoter(newVoterAddress)
                    call newVoterAddress.receiveAuthorization()
                        returning resultCode such that resultCode = "SUCCESS"

    // Version without flow names, with handle:
    transaction authorizeVoter(newVoterAddress : address):
        only when contractCreator = msg.sender then
            voterSource --- newVoterAddress --> authorizedVoters
            handle:
                on fail with Err:
                    revert("This address is already authorized! Do not re-authorize it.")
                on success:
                    emit AuthorizedVoter(newVoterAddress)
                    call newVoterAddress.receiveAuthorization()
                        returning resultCode such that resultCode = "SUCCESS"

    // Finally, note that it is easy to support structures like
    transaction T(x):
        handle {
            A --- x --> B
            C --- y --> D
            E --- z --> F
        } with {
            on fail:
                // Stuff
            on success:
                // Stuff
        }

    // by a mechanical translation to the following, which is easy with both of the proposed syntax options above.
    transaction T(x):
        F1: A --- x --> B
        F2: C --- y --> D
        F3: E --- z --> F
        on fail {F1,F2,F3}:
            // Stuff
        on success {F1,F2,F3}:
            // Stuff
}

