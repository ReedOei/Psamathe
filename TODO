- How to handle events?
    - Could link to flows somehow, so whenever there is a flow of some resource, there's a corresponding event fired.

- How to deal with return values

- How to represent states
    - Not really happy with the standard solidity way of doing states
    - I feel like we can use flows to make this work nciely.

- How to handle internal/external calls?

- Only functions that have a parameter with type ether can receive ether
    - Also, can have at most one parameter with type ether

- How to handle inheritance and interfaces, if at all?
    - In particular, how to interface with Solidity or Obsidian code, if needed?

- Maybe visualize transactions via diagrams?

- Every primitive type has a corresponding endless pool:
    - e.g., pool addresses for address, pool nats for nat, pool strings for string, etc.
    - We could also just not use pools and such but use normal assignment or whatever.
        - Much less fun, and sort of annoying because there's two sets of semantics.
        - We can use just one set of semantics by doing the following:
            x := e
            means
            flow e from t to x
            where t is a pool that has the type of x

            This syntax can only be used when t is a non-asset type.

- Should authentication be first-class?
    - Probably not. Would be restrictive, and if people want something better they need to be able to implement it themselves.

- Fungible and non-fungible resources actually behave very similarly, so might be easy to combine into some parametric polymorphism.

- Automatically handle short-address attack

- Formalize as graphs?

