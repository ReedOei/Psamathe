// A version with a special-cased fungible modifier which you can provide functions to
contract C {
    type SuffixString is fungible(myEmpty, mySingle, myCombine, mySelect) asset string

    view myEmpty() returns string := ""
    view mySingle(str : string) returns string := str
    view myCombine(str1 : string, str2 : string) returns option string := some(str1 ++ str2)
    view mySelect(str1 : string, str2 : string) returns option (string * string) :=
        if str1.endswith(str2) then
            some(str1.take(str1.length - str2.length), str2)
        else
            emptyval
}

// Transformers are allowed to do flows, but no packs or unpacks (they are not considered part of a contract, so it doesn't make sense to pack or unpack).
// Standalone transformers are typechecked in an empty environment
// Transformers inside of transactions will be typechecked in the current environment, but are not allowed to change anything other than their parameter.

// Polymorphism version
interface fungible(A) {
    type Elem
    type Selector

    empty : {} ~> A
    single : Elem ~> A
    combine : A ~> A ~> option A
    contains : A ~> Selector ~> bool
    select : A ~> Selector ~> option { remaining : A, selected : A }

    // Properties:
    combine(x, empty) = combine(empty, x) = some(x)

    if select(a, b) = some(x, y) then combine(x, y) = some(a)

    // Note that these only apply if Selector = A.
    select(a, a) = some({ remaining: empty, selected: a })
    select(combine(a, b), b) = some({ remaining: a, selected: b })

    if contains(a, b) then select(a, b) = some(...)
}

default fungible(nat) {
    type Elem is nat
    type Selector is nat

    transformer empty(_ : unit) returns nat := 0
    transformer single(e : nat) returns nat := e
    transformer combine(a : nat, b : nat) returns option nat := {
        var res : nat
        a --> res
        b --> res
        some(res)
    }
    transformer select(a : nat, b : nat) returns option nat := {
        if b <= a {
            var selected : nat
            a --[ b ]-> selected
            some({ remaining: a, selected: selected })
        } else {
            none
        }
    }
}

default fungible(list a, a, a + list a) {
    view empty() returns list a := []
    view single(x : a) returns a := [x]
    view combine(xs : list a, ys : list a) returns list a := {
        var temp : list a
        xs --> temp
        ys --> temp
        return temp
    }
    view select(xs : list a,
}

default fungible(map k => v, mapitem k => v, k + (mapitem k => v) + (map k => v) + (k * v)) {

}

// By default we will select a fungible implementation by

// Can declare a custom implementation via

// Then we can declare a type matches an interface by:

type Token is fungible

