// The actual type of the hashtable is:
// any list ! { hash : ! nat, vals : any list ! { key : ! nat, value : ! nat } }
// This represents a list of entries, each storing a list of values to handle the case of collisions.

// Note that this is only **kind of** a hashmap (the time complexities are wrong, because there's no nth operation to give constant time list lookup).

transformer hash(k : ! nat) -> hashed : ! nat {
    // could be something more creative, but for now
    k --> hashed
}

transformer emptyMap(dummy : ! {})
    -> res : any list ! { hash : ! nat, vals : any list ! { key : ! nat, value : ! nat } }
{
}

transformer hasHash(k : ! nat,
                    bucket : ! { hash : ! nat, vals : any list ! { key : ! nat, value : ! nat } })
    -> res : ! bool
{
    try {
        k --> hash() --> var hashed : ! nat
        bucket.hash --> var bucketHash : ! nat
        [ bucketHash ] --[ hashed ]-> var temp : ! nat
        true --> res
    } catch {
        false --> res
    }
}

transformer hasKey(k : ! nat, entry : ! { key : ! nat, value : ! nat}) -> res : ! bool {
    try {
        entry.key --> var entryKey : ! nat
        [ entryKey ] --[ k ]-> var temp : ! nat
        true --> res
    } catch {
        false --> res
    }
}

transformer insert(args : ! { m : any list ! { hash : ! nat, vals : any list ! { key : ! nat, value : ! nat } },
                              k : ! nat,
                              v : ! nat })
    -> res : nonempty list ! { hash : ! nat, vals : any list ! { key : ! nat, value : ! nat } }
{
    args.m --> var m : any list ! { hash : ! nat, vals : any list ! { key : ! nat, value : ! nat } }
    args.k --> var k : ! nat
    args.v --> var v : ! nat
    try {
        // If the hash already appears in the map
        m --[ ! such that hasHash(k) ]-> var bucket : ! { hash : ! nat, vals : any list ! { key : ! nat, value : ! nat } }
        { key : ! nat |-> k, value : ! nat |-> v } --> var newEntry : ! { key : ! nat, value : ! nat }
        [ newEntry ] --> bucket.vals
        [ bucket ] --> m
    } catch {
        // Otherwise we need to construct a new bucket holding just the newly inserted key-value pair.
        copy(k) --> hash() --> var hashed : ! nat
        { key : ! nat |-> k, value : ! nat |-> v } --> var newEntry : ! { key : ! nat, value : ! nat }
        [ newEntry ] --> var vals : any list ! { key : ! nat, value : ! nat }
        { hash : ! nat |-> hashed, vals : any list ! { key : ! nat, value : ! nat } |-> vals } --> var newBucket : ! { hash : ! nat, vals : any list ! { key : ! nat, value : ! nat  } }
        [ newBucket ] --> m
    }
    m --> res
}

// This is "select" in the Psamathe sense, meaning it returns the new value and the new map without the key-value pair.
// In this case, this is not necessary, because nats aren't assets, but in general you wouldn't want to just delete the value in the map.
transformer select(m : any list ! { hash : ! nat, vals : any list ! { key : ! nat, value : ! nat } },
                   k : ! nat)
    -> res : ! { newMap :  any list ! { hash : ! nat, vals : any list ! { key : ! nat, value : ! nat } },
                 v : ! nat }
{
    // Extract the bucket we care about. This will fail if the bucket is not present.
    m --[ ! such that hasHash(k) ]-> var bucket : ! { hash : ! nat, vals : any list ! { key : ! nat, value : ! nat } }
    bucket.vals --[ ! such that hasKey(k) ]-> var resultKvPair : ! { key : ! nat, value : ! nat }
    resultKvPair.value --> var resultVal : ! nat
    // Put the rest of the bucket back
    [ bucket ] --> m

    { newMap : any list ! { hash : ! nat, vals : any list ! { key : ! nat, value : ! nat } } |-> m,
      v : ! nat |-> resultVal } --> res
}

;

{} --> var dummy : ! {}
[ dummy ] --> emptyMap() --> var m : any list ! { hash : ! nat, vals : any list ! { key : ! nat, value : ! nat } }

7 --> var k : ! nat
24 --> var v : ! nat
{ m : any list ! { hash : ! nat, vals : any list ! { key : ! nat, value : ! nat } } |-> m,
  k : ! nat |-> k,
  v : ! nat |-> v } --> insert() --> m

