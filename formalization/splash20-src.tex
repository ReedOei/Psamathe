\documentclass[dvipsnames, usenames, sigconf]{acmart}

\usepackage{listings}
\usepackage{hyperref}
\usepackage{tikz-cd}
% \usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bm}
\usepackage{listings}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{float}
\usepackage{subcaption}
\usepackage{xcolor}
% \usepackage[utf8x]{inputenc}
\usepackage[safe]{tipa}
% \usepackage[inline]{enumitem}

%% \BibTeX command to typeset BibTeX logo in the docs
% \AtBeginDocument{%
%   \providecommand\BibTeX{{%
%     \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
% \setcopyright{acmcopyright}
% \copyrightyear{2018}
% \acmYear{2018}
% \acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
% \acmConference[Woodstock '18]{Woodstock '18: ACM Symposium on Neural
%   Gaze Detection}{June 03--05, 2018}{Woodstock, NY}
% \acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%   June 03--05, 2018, Woodstock, NY}
% \acmPrice{15.00}
% \acmISBN{978-1-4503-XXXX-X/18/06}

%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

\input{LaTeX/macros.tex}
\input{solidity-latex-highlighting/solidity-highlighting.tex}
\input{flow-highlighting.tex}
\input{macros.tex}

\settopmatter{printfolios=true}

\begin{document}

%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{\langName: A DSL for Safe Blockchain \AssetTxt{}s}

%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
% \author{Reed Oei}
% \email{reedoei2@illinois.edu}
% \affiliation{%
%   \institution{University of Illinois}
%   \city{Urbana}
%   \country{USA}
% }

%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Trovato and Tobin, et al.}

%% The abstract is a short summary of the work to be presented in the
%% article.
% \begin{abstract}
%     Abstract.
% \end{abstract}

%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
% \begin{CCSXML}
% <ccs2012>
%  <concept>
%   <concept_id>10010520.10010553.10010562</concept_id>
%   <concept_desc>Computer systems organization~Embedded systems</concept_desc>
%   <concept_significance>500</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010575.10010755</concept_id>
%   <concept_desc>Computer systems organization~Redundancy</concept_desc>
%   <concept_significance>300</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010553.10010554</concept_id>
%   <concept_desc>Computer systems organization~Robotics</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10003033.10003083.10003095</concept_id>
%   <concept_desc>Networks~Network reliability</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Computer systems organization~Embedded systems}
% \ccsdesc[300]{Computer systems organization~Redundancy}
% \ccsdesc{Computer systems organization~Robotics}
% \ccsdesc[100]{Networks~Network reliability}

% %% Keywords. The author(s) should pick words that accurately describe
% %% the work being presented. Separate the keywords with commas.
% \keywords{datasets, neural networks, gaze detection, text tagging}

%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

Blockchains are increasingly used as platforms for applications, called \emph{smart contracts}, which automatically manage transactions in an unbiased, mutually agreed-upon way.
Commonly proposed and implemented applications for the blockchain often revolve around managing \emph{digital assets}, such as smart contracts for supply chain management~\cite{SupplyChainUse}, healthcare~\cite{HealthcareUse}, and other applications which require careful management of their respective assets such as voting, crowdfunding, or auctions~\cite{Elsden18:Making}.
One of the most common is a \emph{token contract}---about 73\% of high-activity contracts are token contracts~\cite{OlivaEtAl2019}.
On the Ethereum blockchain~\cite{wood2014ethereum}, there are many token standards, including ERC-20, ERC-721, ERC-777, ERC-1155~\cite{erc20,erc721,erc777,erc1155}.

Smart contracts cannot be patched after being deployed, even if a security vulnerability is discovered.
Therefore, developers must carefully review contracts before deployment, and some use an independent auditing service to help with this process.
Despite this extra care, discoveries of vulnerabilities still occur regularly, often costing large amounts of money.
The well-known DAO attack~\cite{DAO}, discussed in Section~\ref{sec:ex-dao-attack}, caused the loss of over 40 million dollars, and was due to a reentrancy issue.
Some estimates suggest that as much as 46\% of smart contracts may have some vulnerability~\cite{luuOyente}.

\langName (\langNamePronounce) is a new programming language we are designing around a new abstraction, called a \emph{flow}, representing an atomic transfer operation, which is widely applicable to smart contracts managing digital \assetTxt{}s.
It will also provide features to mark certain values as \emph{\assetTxt{}s}, with various \emph{modifiers} to control their use, which combine with flows to make certain classes of bugs impossible.
Solidity, the most commonly-used language for writing smart contracts on the Ethereum blockchain~\cite{EthereumForDevs}, does not make any effort to provide analogous support for managing \assetTxt{}s.

\paragraph{Contributions}

We make the following contributions with \langName.
\begin{itemize}
    \item \textbf{Flow abstraction}: \langName uses a new abstraction called a \emph{flow} to encode semantic information about the flow of \assetTxt{}s into the code.
    \item \textbf{Safety guarantees}: \langName ensures that \assetTxt{}s are properly managed; eliminating reuse, \assetTxt-loss, and duplication bugs through the use of the flow abstraction and a type system tracking \emph{type quantities}.
    \item \textbf{Conciseness}: \langName makes writing typical smart contracts more concise by handling common patterns and pitfalls automatically.
\end{itemize}

% \reed{Optimizations? Need an implementation to evaluate.}
%     ALso, Some of the Solidity contracts are actually inefficient because:
%     They use lots of modifiers which repeat checks (see reference implementation of ERC-721).
%     They tend to use arrays to represent sets.
%  We can evaluate this by profiling or a simple opcode count (which is not only a proxy for performance, but also means that deploying the contract will be cheaper).

\section{Language}\label{sec:lang}
A \langName program is made of \emph{contracts}, each containing \emph{declarations}, such as \emph{fields}, \emph{types}, and \emph{functions}.
A contract is the high-level grouping of functionality, just as in Solidity; each contract instance in \langName represents a contract on the blockchain.
Fields function as the persistent storage of the contract, whose data is kept on the blockchain.
Type declarations are the primary way to use the type system of \langName, providing a way of annotating values as \assetTxt{}s (as well as other modifiers, discussed in Section~\ref{sec:lang-modifiers}).
We distinguish between three types of function: \emph{transactions}, \emph{views}, and \emph{transformers}.
Transactions and views are both \emph{methods}, which may access the fields of a contract; a transaction can read \textbf{and} write fields, whereas a view may only read fields.
A transformer is a \textbf{pure} function, which is not part of any contract: it may contain flows and other statements, and it may mutate \textbf{local} state, but it cannot mutate the state of any contract.

Figure~\ref{fig:erc20-transfer-flow} shows a simple contract declaring a type, a field, and a transaction, which implements the core functionality of ERC-20's \lstinline{transfer} function (see Section~\ref{sec:erc20-impl} for more details on ERC-20).
\begin{figure}[ht]
    \centering
    \lstinputlisting[language=flow]{splash20-examples/erc20-transfer.flow}
    \caption{A contract with a simple \lstinline{transfer} function in \langName, which transfers \lstinline{amount} tokens from the sender's account to the destination account.
It is implemented with a single flow, which automatically checks all the preconditions to ensure the transfer is valid.}
    \label{fig:erc20-transfer-flow}
\end{figure}
% \begin{figure*}[h]
%     \centering
%     \begin{subfigure}[t]{0.49\textwidth}
%         \centering
%         \lstinputlisting[language=Solidity]{splash20-examples/erc20-transfer.sol}
%         \caption{Solidity implementation of ERC-20's \lstinline{transfer} function.}
%         \label{fig:erc20-transfer-sol}
%     \end{subfigure}%
%     \hfill
%     \begin{subfigure}[t]{0.49\textwidth}
%         \centering
%         \lstinputlisting[language=flow]{splash20-examples/erc20-transfer.flow}
%         \caption{\langName implementation of ERC-20's \lstinline{transfer} function.}
%         \label{fig:erc20-transfer-flow}
%     \end{subfigure}
%     % \caption{A Solidity and a \langName implementation of the core functions of the ERC-20 standard.}
%     \label{fig:erc20-transfer}
% \end{figure*}
% \reed{Not sure how to get the bounding box to be right in each column...}

\subsection{Syntax}
\begin{figure}[t]
\setlength{\tabcolsep}{1pt}
\begin{tabular}{l r l l}
    $\mathfrak{q}$ & \bnfdef & $\exactlyone$ \bnfalt $\any$ \bnfalt $\nonempty$ & (selector quantifiers) \\
    $\mathcal{Q}$ & \bnfdef & $\mathfrak{q}$ \bnfalt $\emptyq$ \bnfalt $\every$ & (\typeQuantities) \\
    $T$ & \bnfdef & \boolt \bnfalt $\natt$ \bnfalt $\map~\tau~\Rightarrow~\sigma$ \bnfalt $t$ \bnfalt $\ldots$ & (base types) \\
    $\tau$ & \bnfdef & $\mathcal{Q}~T$ & (types) \\
    $\mathcal{V}$ & \bnfdef & $n$ \bnfalt \true \bnfalt \false \bnfalt $\emptyval$ \bnfalt $\ldots$ & (values) \\
    $\mathcal{L}$ & \bnfdef & $x$ \bnfalt $x.x$ & (locations) \\
    $E$ & \bnfdef & $\mathcal{V}$ \bnfalt $\mathcal{L}$ \bnfalt $\total~t$ \bnfalt $\ldots$ & (expressions) \\
    $s$ & \bnfdef & $\mathcal{L}$ \bnfalt $\everything$ \bnfalt $\mathfrak{q}~x : \tau~\suchthat~E$ & (selector) \\
    $\mathcal{S}$ & \bnfdef & $\mathcal{L}$ \bnfalt $\newc~t$ & (sources) \\
    $\mathcal{D}$ & \bnfdef & $\mathcal{L}$ \bnfalt $\consume$ & (destinations) \\
    $F$ & \bnfdef & $\mathcal{S} \sends{s} \mathcal{D}$ & (flows) \\
    $\Stmt$ & \bnfdef & $F$ \bnfalt $\Stmt ; \Stmt$ \bnfalt $\ldots$ & (statements) \\
    $M$ & \bnfdef & \fungible \bnfalt \immutable \bnfalt \unique & \\
        & \bnfalt & \consumable \bnfalt \asset & (type modifiers) \\
    $\Decl$ & \bnfdef & $\type~t~\is~\overline{M}~T$ & (type declaration) \\
            & \bnfalt & $\transaction~m(\overline{x : \tau}) \to x : \tau~\doC~\Stmt$ & (transactions) \\
            & \bnfalt & $\ldots$ & \\
    $\Con$ & \bnfdef & $\contract~C~\{~\overline{\Decl}~\}$ & (contracts) \\
\end{tabular}
\caption{A fragment of the abstract syntax of the core calculus of \langName, a simplified form of the surface language.}
\label{fig:lang-syntax-frag}
\end{figure}

Figure~\ref{fig:lang-syntax-frag} shows a fragment of the syntax of the core calculus of \langName, which uses A-normal form and makes several other simplifications to the surface \langName language.
These simplifications are performed automatically by the compiler.
\reed{TODO: We have formalized this core calculus (in K???).}

\subsection{Flows}
\langName is built around the concept of a \emph{flow}, an atomic, state-changing operation describing the transfer of values.
Each flow has a \emph{source} and a \emph{destination}; they may optionally have a \emph{selector} or a \emph{transformer}, which default to $\everything$ and the identity transformer, respectively.
The source of a flow \emph{provides} values, the destination of the flow \emph{accepts} these values, and the selector describes which subpart of the value(s) in the source should be transferred to the destination.
The source and destination of a flow are \emph{storages}, which are either variables or one of the special storages $\newc~t$ or $\consume$.
A selector is a function that takes as input the current value of the storage, and outputs the value(s) to select.
Selectors act can be used like a filter in functional programming, or like a \lstinline{WHERE} in SQL.
Using a transformer in a flow is like mapping a function over the collection of values being flowed.

Using a \emph{flow-based} approach provides the following advantages over the typical \emph{assignment-based} approach most languages use (e.g., incrementing, then decrementing):
\begin{itemize}
    \item \textbf{Precondition checking}: For a flow to succeed, the source must have enough \assetTxt{}s and the destination must be capable of receiving the \assetTxt{}s flowed.
        For example, a flow of money would fail if there is not enough in the source, or if there is too much in the destination; the latter may occur because of overflow.
        Flows can also fail for other reasons: a developer may specify that a certain flow must send all \assetTxt{}s matching a predicate, but in addition specify an expected \emph{quantity} that must be selected: any number, exactly one, or at least one.
        The former will always succeed, but the latter two may cause the flow to fail.
    \item \textbf{Data-flow tracking}: It is clear where the resources are flowing from the code itself, which may not be apparent in complicated contracts, such as those involving transfer fees.
        Furthermore, developers must explicitly mark all times that \assetTxt{}s are \emph{consumed}, and only assets marked as \flowinline{consumable} may be consumed.
        This restriction prevents \assetTxt{}s, such as ether from being consumed.
    \item \textbf{Error messages}: When a flow fails, \langName provides automatic, descriptive error messages, such as \lstinline{"Cannot flow '<amount>' Token from account[<src>] to account[<dst>]: source only has <balance> Token."}.
        By default, Solidity provides no error messages, forcing developers to write their own.
        Flows enable creating such messages by encoding the necessary semantic information into the program, instead of using low-level operations like increment and decrement or insert and delete.
\end{itemize}

\subsection{Type Quantities}
When a \langName program is type checked, each variable has an associated \emph{type quantity} at every point in the program, which provides an approximation of the number of values the variable holds.
The list of allowed type quantities is: $\emptyq, \any, \exactlyone, \nonempty, \every$ (note ``$\exactlyone$'' means ``exactly one'').
Only $\emptyq$ \assetTxt variables may be dropped, ensuring that unused \assetTxt{}s not dropped.
Type quantities are \textbf{not} required in the surface language, and they will be added automatically; for example, \flowinline{var toks : set Token := \{\}} is inferred to be an \flowinline{empty set Token}, whereas \flowinline{var C : Bank := new Bank()} is inferred to be \flowinline{! Bank}.

Type quantities are primarily updated by flows.
For example, after checking the flow \flowinline{A --[ everything ]-> B}, we now know that \flowinline{A} is empty, and depending on the type quantity that \flowinline{A} used to have, we may now know that \flowinline{B} is also empty (if \flowinline{A} was empty), nonempty, or any other type quantity (other than $\every$).
Type quantities can also be updated by expressions, which can move values to other variables.
For example, after checking \flowinline{var x : (Token, Token) := (a, b)}, creating a new pair, both \flowinline{a} and \flowinline{b} are $\emptyq$, as the assets they used to hold are now in \flowinline{x}.

The type quantity system provides the benefits of \emph{linear types}, but gives a more precise analysis of the flow of values in a program.
Many variables are supposed to hold exactly one value; this corresponds to being non-null in languages like Java.
The type quantity system allows us temporarily ``empty out'' the variable, while statically ensuring that it contains exactly one value before we finish.
We can also use it to specify more precise types for our variables, such as declaring an argument to a transaction must be a \flowinline{nonempty list}.
Finally, we can use type quantities to specify our \textbf{expectations} about program behavior in a way that can be automatically checked.
For example, suppose that \flowinline{A : set address} and \flowinline{B : empty address}, and consider the following flow
\begin{flow}
A --[ ! account such that isAdmin(account) ]-> B
\end{flow}
We know that B must be \flowinline{! address} if the flow was successful, and we have made it clear to the program and the reader that there should be exactly one admin address in \flowinline{A}.

\subsection{Modifiers}\label{sec:lang-modifiers}
\emph{Modifiers} can be used to place constraints on how values are managed: \flowinline{asset}, \flowinline{fungible}, \flowinline{unique}, \flowinline{immutable}, and \flowinline{consumable}.
A \flowinline{asset} is a value that must not be reused or accidentally lost.
A \flowinline{fungible} value represents a quantity which can be \textbf{merged}, and it is \textbf{not} \flowinline{unique}.
A \flowinline{unique} value can only exist in at most one storage; it must be \flowinline{immutable} and an \flowinline{asset} to ensure it is not duplicated.
A \flowinline{immutable} value cannot be changed; in particular, it cannot be the source or destination of a flow, the only state-changing construct in \langName.
A \flowinline{consumable} value is an \flowinline{asset} that it is sometimes appropriate to dispose of; however, this disposal must be done via the \flowinline{consume} construct, a way of documenting that the disposal is intentional.

All of these constraints, except for uniqueness, are enforced statically.
Uniqueness is enforced at creation time by dynamically checking that the new value has never been created before.
After this initial check, we can be sure that the values are unique because the type system will not allow an existing unique value to be duplicated.
\reed{What if someone passes us an argument of a unique type in a public transaction? Is that even possible?}

For example, ERC-20 tokens are \flowinline{fungible}, while ERC-721 tokens are best modeled as being both \flowinline{unique} and \flowinline{immutable}.
By default, neither is \flowinline{consumable}, but one of the common extensions of both standards is to add a \flowinline{burn} function, which allows tokens to be destroyed by users with the appropriate authentication.
In this case, it would be appropriate to add the \flowinline{consumable} modifier.

\langName also supports data structures that make working with \assetTxt{}s easier, such as \emph{linkings}, a bidirectional map between keys and collections of values to support modeling of an \emph{account} holding a collection of \assetTxt{}s.
A \flowinline{linking K <=> C V} is a \flowinline{map K => C V} with additional operations, where \flowinline{K} is the key type, \flowinline{V} is the value type, and \flowinline{C} is some collection type constructor, such as \flowinline{list} or \flowinline{set}.
The additional operations supported are \flowinline{L.hasOwner(v)} and \flowinline{L.ownerOf(v)}, where \flowinline{L : linking K <=> C V} and \flowinline{v : V}.
\flowinline{L.hasOwner(v)} returns true if and only if there is some \flowinline{k : K} such that \flowinline{v in L[k]} is true.
\flowinline{L.ownerOf(v)} returns some \flowinline{k : K} such that \flowinline{v in L[k]}, if it exists.
If it does not, it throws an error.
\reed{I have some ideas about adding interfaces to the language, which I would love to do but it would complicate things.}
% Specifically, a linking implements the following interface for any collection type \flowinline{C}.
% Note that the specific syntax is not allowed in an interface declaration, but is used because it is syntax used in the language to write the linking type.
% \reed{Either need to finish up the interface proposal, or write this in another way}
% \begin{lstlisting}[language=flow]
% interface linking K <=> C V where C is collection {
%     empty : linking K <=> C V
%     get : (linking K <=> C V) ~> K ~> C V
%     put : (linking K <=> C V) ~> K ~> V ~> linking K <=> C V
%     hasOwner : (linking K <=> C V) ~> V ~> bool
%     ownerOf : (linking K <=> C V) ~> V ~> K
% }
% \end{lstlisting}
% Note that some operations may result in errors. %, which we represent via $\flowError$ below.
% It also satisfies the following laws; note that \flowinline{k : K}, \flowinline{v : V}, and \flowinline{L : linking K <=> C V}, and all variables are universally quantified.
% \begin{lstlisting}[language=flow]
% if v not in get(L, k) { (v in get(put(L, k, v), k)) = true } else { put(L, k, v) = $\flowError$ }
% get(empty, k) = $\flowError$
% \end{lstlisting}
See Figure~\ref{fig:erc721-impl-flow} for some example uses of this structure.
Though it is possible to partially implement linkings as a library in Solidity, in \langName, we can guarantee that looking up the owner of a value in linking, if it has a \flowinline{unique} type, is a \textbf{well-defined} operation.

\subsection{Error Handling}
Computation on blockchains like the Ethereum blockchain is grouped into units called \emph{transactions}.
Transactions in the same \emph{block} are executed in a nondeterministic, but sequential, order.
Transactions either succeed or they fail and revert all changes.
\langName also has transactional semantics: a sequence of flows will either all succeed, or, if a single flow fails, the rest will fail as well.
If a sequence of flows fails, it ``bubbles up'', like an exception, until it either: a) reaches the top level, at which point the entire transaction fails; or b) reaches a \flowinline{catch}, in which case only the changes made inside the corresponding \flowinline{try} block will be reverted, and the code inside the \flowinline{catch} block will be executed.

\subsection{Comparison with Solidity}
The concept of contracts in \langName maps directly Solidity's concept of contracts.
Transactions, views, and transformers all map to the concept of \lstinline{function} in Solidity: a transaction is a function that is public by default, a view is a function with the \lstinline{view} modifier, and a transformer is a function with the \lstinline{pure} modifier.
A type declaration in \langName is best modeled by a \lstinline{struct} in Solidity, although type declarations are more flexible: Solidity has does not support any of the modifiers that \langName does (note Solidity has its own concept of modifiers that is unrelated).
\reed{Probably should put more effort into explanation for people who don't know Solidity (at least, if we submit to a non-blockchain venue).}

The \langName language provides all of the primitive types that Solidity does, with additional support for types such as linkings, explained above.
Solidity also exhibits several atypical behaviors, such as acting as those all keys in a mapping exist, and providing the default value whenever a new key is used.
This leads to ad-hoc workarounds, like those shown in Sections~\ref{sec:erc721-impl} and~\ref{sec:voting-impl}.

Before version 0.6.0, for the first four years since its release five years ago, Solidity did not have a try-catch construct~\cite{SolidityTryCatch}.
The newly-added try-catch construct behaves similarly to that of \langName, as both will revert the changes made when an exception occurs.
However, Solidity's try-catch is structured in an atypical way, only allowing catching errors from a single expression, which must be an external call or a contract creation call.

\section{Examples}
In this section, we show several example smart contracts, with a Solidity implementation and a \langName implementation, and discuss the benefits of each implementation.
In each example, we only show the fragment of the code that is necessary for space reasons, but the full Solidity and \langName implementations can be found in our repository.
\reed{Do this}
\begin{figure*}[ht]
    \centering
    \begin{subfigure}[t]{0.49\textwidth}
        \centering
        \lstinputlisting[language=Solidity]{splash20-examples/voting.sol}
        \caption{Solidity implementation of the core voting functions~\cite{solidityByExample}.}
        \label{fig:voting-impl-sol}
    \end{subfigure}%
    \hfill
    \begin{subfigure}[t]{0.49\textwidth}
        \centering
        \lstinputlisting[language=flow]{splash20-examples/voting.flow}
        \caption{\langName implementation of the core voting functions.}
        \label{fig:voting-impl-flow}
    \end{subfigure}
    \caption{A voting contract with a set of proposals, for which each user must first be given permission to vote by the chairperson, assigned in the constructor of the contract (not shown).
    Each user can vote exactly once for exactly one proposal.
    The proposal with the most votes wins.}
    \label{fig:voting-impl}
\end{figure*}

\subsection{ERC-20}\label{sec:erc20-impl}
ERC-20 is a standard for smart contracts that manage \textbf{fungible} tokens, and provides a bare-bones interface for this purpose.
ERC-20 is one of the commonly implemented standards on the Ethereum blockchain.
Each ERC-20 contract manages the ``bank accounts'' for its own tokens, keeping track of which users, identified by addresses, have some number of tokens.
We focus on one core function from ERC-20, the \lstinline{transfer} function.
\reed{Cite all Solidity code}
\begin{figure}[ht]
    \centering
    \lstinputlisting[language=Solidity]{splash20-examples/erc20-transfer.sol}
    \caption{An implementation of ERC-20's \lstinline{transfer} function in Solidity.
        All preconditions are checked manually.
        Note that we must include the \lstinline{SafeMath} library (not shown), which checks for underflow/overflow, to use the \lstinline{add} and \lstinline{sub} functions.}
    \label{fig:erc20-transfer-sol}
\end{figure}
Figure~\ref{fig:erc20-transfer-sol} shows a Solidity implementation of the ERC-20 function \lstinline{transfer} (cf. Figure~\ref{fig:erc20-transfer-flow}).
Note that event code has been omitted, because \langName handles events in the same way as Solidity.
This example shows the advantages of the flow abstraction in precondition checking and error messages. \reed{rephrase, because you can't see the error messages, but it's still part of the advantages...}
In this case, the balance of the sender must be at least as large as the amount sent, and the balance of the destination must not overflow when it receives the tokens.
Code checking these two conditions is automatically inserted, ensuring that the checks cannot be forgotten.

\subsection{ERC-721}\label{sec:erc721-impl}

ERC-721, like ERC-20, is a token standard for the Ethereum blockchain.
ERC-721 is a standard for tokens managing \emph{nonfungible} tokens; that is, tokens that are unique.
The ERC-721 standard requires many invariants hold, including:
    the tokens must be unique,
    the tokens must be owned by at most one account,
    at most one non-owning account can have \emph{approval} for a token, and only if that token has been minted,
    we must be able to support \emph{operators} who can manage all of the tokens of a user,
    among others.
Because \langName is designed to manage \assetTxt{}s, it has features to help developers ensure that these correctness properties hold.

Figures~\ref{fig:erc721-impl-sol} and~\ref{fig:erc721-impl-flow} show implementations in Solidity and \langName, respectively, of the ERC-721 function \lstinline{transferFrom}.
The Solidity implementation is extracted from a reference implementation of ERC-721 given on the official Ethereum EIP page.
Note that all helper functions and modifiers have been unfolded, and some redundant code, present in the original implementation, has been removed for space reasons.

A \langName implementation has several benefits: because of the \assetTxt abstraction, we can be sure that token references will not be duplicated or lost; because \lstinline{Token} has been declared as $\unique$, we can be sure that we will not mint two of the same token.
In addition to the invariants required by the specification, there are also internal invariants which the contract must maintain, such as the connection between \lstinline{idToOwner} and \lstinline{ownerToNFTokenCount}, which are handled automatically in the \langName version.
This example demonstrates the benefits of having $\unique$ \assetTxt{}s and having the linking data structure built into the language.

\subsection{Voting}\label{sec:voting-impl}
One proposed use for the blockchain is smart contracts for managing voting \reed{cite}.
Figures~\ref{fig:voting-impl-sol} and~\ref{fig:voting-impl-flow} show the core of an implementation of a simple voting contract in Solidity and \langName, respectively.
This example shows that \langName is suited for a range of applications, as we can use the $\unique$ modifier to remove certain incorrect behaviors, shown in Figure~\ref{fig:voting-impl}.
In this application, the use of $\unique$ ensures that each user, represented by an \lstinline{address}, can be given permission to vote at most once, while the use of $\asset$ ensures that votes are not lost or double-counted.
Additionally, the Solidity implementation is more verbose than the \langName implementation because it must work around the limitations of Solidity's mappings.
In this example, the declaration of the \lstinline{weight} and \lstinline{voted} members of the \lstinline{Voter} struct exist so that the contract can tell whether a voter has the default values, was authorized to vote, or has already voted.

\subsection{The DAO attack}\label{sec:ex-dao-attack}
One of the most financially impactful bugs in a smart contract on the Ethereum blockchain was the bug in the DAO contract which allowed a large quantity of ether, worth over 40 million dollars at the time, to be stolen~\cite{OlivaEtAl2019}.
The bug was caused by a reentrancy-unsafe function in the contract, illustrated below.

The Solidity function shown below allows a user to withdraw their balance of ether whenever they wish.
It does this by first transferring the ether from the contract to the user's address, then decreasing the user's balance.
However, in Ethereum, a transfer of ether also calls a special function on the receiving address, when it is a contract address, called a \emph{fallback} function.
In this function, arbitrary code may be executed, and because \lstinline{call.value()} was used, this call has access to all of the remaining gas of the transaction.
A malicious contract can use this to perform a \emph{reentrant} call back into the \lstinline{withdrawBalance} function, and withdraw their balance again---the user's balance has not been decreased yet.
The fix in this case is a simple swap of the last two lines of the function, but reentrancy issues can be more complicated than this.
\reed{The below is from \url{https://consensys.github.io/smart-contract-best-practices/known_attacks/}}
\begin{lstlisting}[language=Solidity]
function withdrawBalance() public {
    uint amountToWithdraw = userBalances[msg.sender];
    // At this point, the caller's code is executed, and
    // can call withdrawBalance again
    require(msg.sender.call.value(amountToWithdraw)(""));
    userBalances[msg.sender] = 0;
}
\end{lstlisting}

In \langName, this attack could not have occurred for several reasons.
Consider the following implementation of the same function in \langName given below.
\begin{lstlisting}[language=flow]
transaction withdrawBalance():
    userBalances[msg.sender] --> msg.sender.balance
\end{lstlisting}
Because of the additional information encoded in the flow construct, we expect that our compiler should be able output the safe version of the above code---reducing the balance before performing the external call---without any developer intervention.
Additionally, \langName forbids any reentrant call from an external source, a similar approach to the Obsidian language~\cite{coblenz2019obsidian}, which would also prevent more complicated reentrancy attacks.

\section{Discussion}

\section{Related Work}
There have been many new blockchain languages proposed, such as Obsidian~\cite{coblenz2019obsidian}, Scilla \reed{cite}, Move \reed{cite}, Nomos \reed{cite}, Flint \reed{cite}. \reed{Others?}

Some of these languages, such as Scilla and Move, were proposed as intermediate-level languages, whereas \langName is intended to be a high-level language.

Several, such as Obsidian, Move, Nomos, and Flint, use linear types to manage \assetTxt{}s similarly to how \langName uses type quantities.
None of the these languages have flows \reed{desribe why flows are a good alternative to whatever mechanisms these languages provide}.
\reed{I would like to make an argument that flows are more intuitive than ownership, but can't really do that.}
Additionally, none of these languages provide support for all the modifiers that \langName does.\reed{should check this to be sure...}
\reed{reentrancy}

\section{Conclusion and Future Work}

We have presented the \langName langauge for writing safer smart contracts.
\langName uses the new flow abstraction, \assetTxt{}s, and modifiers to provide safety guarantees for smart contracts.
We showed several examples of smart contracts in both Solidity and \langName, showing that \langName is capable of expressing common smart contract functionality in a concise manner, while retaining key safety properties.

In the future, we plan to fully implement the \langName language, and complete proofs of all of its safety properties.
We also hope to perform additional studies on the benefits of the language including conducting case studies, comparing the efficiency of the resulting programs, and exploring the applicability of flows to other domains where careful asset management is important, outside of the blockchain.
Finally, we would also like to perform a user study to evaluate the usability of the flow abstraction and the design of the language itself, as well as comparing it to Solidity.

%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{biblio}

\end{document}
\endinput

