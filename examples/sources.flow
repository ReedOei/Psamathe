// Source Definition for a **nonfungible** T:
source S of T
=>
S : map demote(T) => option T
// such that for all x : T, after on create() is run, then S[x] = { v }; i.e., every key is filled.
// Of course, we can't "actually" implement a source like this, because it would contain infinitely many values.
// Instead, we can implement it as the "opposite", so S actually keeps track of which values no longer exist in the map.
// But it's useful as a mental model, because it let's
// Only one source per nonfungible resource is allowed.
// Then to "create" assets we do:

S[x] --> y

// As an example, the source "lunchNameSource" from the voting example would be like the following

type LunchName is nonfungible consumable asset string
source lunchNameSource of LunchName
=>
lunchNameSource : map string => option LunchName

// Creating a resource:
lunchNameSource[newName] --> name

// Alternatively, we could not allow any sources to exist at all, and just have the type name be the default source.
// Then every resource just has a source by default, which seems to make sense.

// **ALL** asset types cannot be mutated, so I **cannot** do:
type A is nonfungible asset set string

x : A
x += { "testing" }

// Because that would change the asset x.
// I don't really know when you would want to do this anyway, so it might not really be an issue.

// Source Definition for a **fungible** T:
source S of T [provides limit]
=>
S : T
// so S holds at most `limit` of T; if no limit is provided, then S has an endless supply of T.

