\documentclass[10pt]{article}

\usepackage{amsmath}
\usepackage{sagetex}
\usepackage{hyperref}
\usepackage{tikz-cd}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bm}
\usepackage{listings}
\usepackage{bbm}
\usepackage{multicol}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{float}
\usepackage[inline]{enumitem}
\usepackage[margin=1.25in]{geometry}
\usepackage[T1]{fontenc}
\usepackage{kpfonts}

\usetikzlibrary{decorations.pathmorphing}

\input{LaTeX/macros.tex}

\lstset{
  frame=none,
  xleftmargin=2pt,
  stepnumber=1,
  numbers=left,
  numbersep=5pt,
  numberstyle=\ttfamily\tiny\color[gray]{0.3},
  belowcaptionskip=\bigskipamount,
  captionpos=b,
  escapeinside={*'}{'*},
  tabsize=2,
  emphstyle={\bf},
  commentstyle=\it,
  stringstyle=\mdseries\rmfamily,
  showspaces=false,
  keywordstyle=\bfseries\rmfamily,
  columns=flexible,
  basicstyle=\small\sffamily,
  showstringspaces=false,
}

\newcommand{\guard}{\bigg|\bigg|}
\newcommand{\newc}{\textbf{\texttt{new}}}
\newcommand{\everything}{\textbf{\texttt{everything}}}
\newcommand{\then}{\textbf{\texttt{then}}}
\newcommand{\this}{\textbf{\texttt{this}}}
\newcommand{\langName}{LANGUAGE-NAME\xspace}
\newcommand{\consumesarr}{\mathrel{\rotatebox[origin=c]{270}{${\looparrowright}$}}}
\newcommand{\consumes}[1]{\stackrel{#1}{\consumesarr}}
\newcommand{\sends}[1]{\stackrel{#1}{\to}}
\newcommand{\emitsarr}{\mathrel{\rotatebox[origin=c]{270}{${\looparrowleft}$}}}
\newcommand{\emits}[1]{\emitsarr #1}
\newcommand{\addresst}{\textbf{\texttt{address}}\xspace}
\newcommand{\stringt}{\textbf{\texttt{string}}\xspace}
\newcommand{\manyt}{\textbf{\texttt{many}}\xspace}
\newcommand{\natt}{\textbf{\texttt{nat}}\xspace}
\newcommand{\byt}{\textbf{\texttt{by}}\xspace}
\newcommand{\stores}{\textbf{\texttt{stores}}\xspace}
\newcommand{\suchthat}{\textbf{s.t.}\xspace}
\newcommand{\returns}{\textbf{\texttt{returns}}\xspace}
\newcommand{\merge}{\rightsquigarrow}
\newcommand{\heldby}{\rightarrowtail}
\newcommand{\one}{\textbf{\texttt{one}}\xspace}
\newcommand{\some}{\textbf{\texttt{some}}\xspace}
\newcommand{\any}{\textbf{\texttt{any}}\xspace}

\begin{document}

\section{Introduction}

\langName is a DSL for implementing programs which manage resources, targeted at writing smart contracts.

\subsection{Contributions}

We make the following main contributions:
\begin{itemize}
    \item \textbf{Safety guarantees}: similar to \reed{or maybe just exactly} linear types\reed{or maybe uniqueness types? need to read more about this}, preventing accidental resource loss or duplication.
        Additionally, provides some amount of reentrancy safety.

        \begin{itemize}
            \item We can evaluate these by formalizing the language and proving them; the formalization is something that would be nice to do anyway.
        \end{itemize}

    \item \textbf{Simplicity}: The language is quite simple---it makes writing typical smart contract programs easier and shorter, because many common pitfalls in Solidity are automatically handled by the language, such as overflow/underflow, checking of balances, short address attacks, etc.

        \begin{itemize}
            \item We can evaluate these by comparing LOC, cyclotomic complexity, etc.
                Not sure what the right metric would be.

            \item We can also evaluate via a user study, but that will take a long(er) time.
        \end{itemize}

    \item \reed{Optimizations?}

        \begin{itemize}
            \item We can evaluate this by profiling or a simple opcode count (which is not only a proxy for performance, but also means that deploying the contract will be cheaper).
        \end{itemize}
\end{itemize}


\section{Language Intro}

The basic state-changing construct in the language is a \emph{flow}.
A flow describes a transfer of a \emph{resource} from one \emph{storage} to another.
A \emph{transaction} is a sequence of flows. \reed{sort of...except for when we use for loops. It's still a set, but it can change based on the inputs/current state.}

A flow can have one of four \emph{modes}:
\begin{enumerate}
    \item send
    \item merge
    \item hold
    \item consume
\end{enumerate}

Each flow also has a \emph{source}, a \emph{destination}, and a \emph{selector}.
The source and destination are two storages which hold a resource, and the selector describes which part of the resource in the source should be transferred to the destination.
A flow may optionally have a \emph{name}.

Note that all flows fail if they can't be performed.
For example, a flow of fungible resources fails if there is enough of the resource, and a flow of a nonfungible resource fails if the selected value doesn't exist in the source location.

\paragraph{Actions}
In addition to flows, transactions may contain \emph{handlers}, which are a pair of a \emph{trigger} and an \emph{action}.
Triggers specify when an action should be executed.
An action can be:
\begin{enumerate}
    \item An event
    \item An external call
    \item An error handler
\end{enumerate}

For example, below, we create a flow with a name \lstinline{F}.
\begin{lstlisting}
F: voterSource --- newVoterAddress --> authorizedVoters
\end{lstlisting}

We can then create handlers for this flow, such as the following:
\begin{lstlisting}
on fail F with Err:
    revert("This address is already authorized! Do not re-authorize it.")
on success F:
    emit AuthorizedVoter(newVoterAddress)
    call newVoterAddress.receiveAuthorization()
        returning resultCode such that resultCode = "SUCCESS"
\end{lstlisting}

It's possible to have triggers which only occur when some subset of actions occurs.
Below, we create two flows.
The trigger \lstinline|on fail {F1,F2}| triggers when any one of the actions \lstinline{F1} or \lstinline{F2} fails.
The trigger \lstinline|on success {F1,F2}| triggers when \textbf{both} the actions \lstinline{F1} and \lstinline{F2} succeed.
\reed{Is this confusing, or is this how you would expect it to work?}
\begin{lstlisting}
F1: A --- x ---> B
F2: C --- y ---> D
on fail {F1,F2}:
    // Stuff
on success {F1,F2}:
    // Stuff
\end{lstlisting}

In fact, all handlers are internally translated into this form, so \lstinline{on fail F} becomes \lstinline|on fail {F}|, and \lstinline{on fail} becomes \lstinline|on fail {F1,F2,...,Fn}|, where \lstinline{F1}, \lstinline{F2}, ..., \lstinline{Fn} are all the flows preceeding the handler.
\reed{I think this is the right way to do it.}

We can also allow the following syntax to be used, with minimal additional implementation troubles:
\begin{lstlisting}
handle {
    A --- x --> B
    C --- y --> D
    E --- z --> F
} with {
    on fail:
        // Stuff
    on success:
        // Stuff
}
\end{lstlisting}

This can be mechanically rewritten to:
\begin{lstlisting}
F1: A --- x --> B
F2: C --- y --> D
F3: E --- z --> F
on fail {F1,F2,F3}:
    // Stuff
on success {F1,F2,F3}:
    // Stuff
\end{lstlisting}

\reed{random note}
The following pattern, while popular in Python \reed{and probably some other languages}, is not possible with this system.
\begin{lstlisting}
try
    A --- x --> B
    C --- y --> D
catch
    E --- z --> F
\end{lstlisting}

So that the second flow only happens if the first fails, you should instead just check whatever condition you're actually interested in.
I don't think this will greatly impact usability, and in fact is probably easier to read because the condition has to be specified, and you won't get unexpected failures causing the flow.
For example, say you want to do the third flow only when there isn't enough money in \lstinline{A} and \lstinline{C} for first two flows to occur.
But the above implementation would also cause the money to be taken from C in the case that there's, for example, and overflow when you transfer to B, or if A has enough money, but not C, which may is desirable.

% // This is also like a try-catch, but more "action-y". Is it though?
% do {
%     voterSource --- newVoterAddress --> authorizedVoters
% } and handle {
%     failure with Err:
%         revert("This address is already authorized! Do not re-authorize it.")

%     success:
%         emit AuthorizedVoter(newVoterAddress)
%         call newVoterAddress.receiveAuthorization()
%             returning resultCode such that resultCode = "SUCCESS"
% }

% // Alternate version, using a more typical looking approach.
% // Pros:
% // - Looks "normal"
% // Cons:
% // - More opportunity for reentrancy bugs.
% // - More complicated program structure (a transaction is just a list of actions/flows vs. having every construct that any other language would have)
% try {
%     voterSource --- newVoterAddress --> authorizedVoters
% } catch (Err) {
%     revert("This address is already authorized! Do not re-authorize it.")
% }
% emit AuthorizedVoter(newVoterAddress)
% if newVoterAddress.receiveAuthorization() != "SUCCESS" then
%     revert();

\section{Examples}
\paragraph{Basic transfer} ERC-20 transfers.
\eq{
    \texttt{transfer}(\texttt{from}, \texttt{to}, \texttt{amount}): \\
    \mathcal{A}[\texttt{from}] \xrightarrow{\texttt{amount}} \mathcal{A}[\texttt{to}]
}

\paragraph{NFT transfer}
For example, ERC-721 token transfers.

\eq{
    \texttt{transfer}(\texttt{from}, \texttt{to}, \texttt{id}): \\
    \mathcal{A}[\texttt{from}] \xrightarrow{\texttt{id}} \mathcal{A}[\texttt{to}]
}

\paragraph{Transfer with fees}
This is fairly common: for example, the contract with the most transactions does this, as do many gambling/auction contracts.
\eq{
    \texttt{transfer}(\texttt{from}, \texttt{to}, \texttt{amount}):
}
\begin{tikzcd}
    & & \mathcal{A}[\texttt{owner}] \\
    \mathcal{A}[\texttt{from}] \arrow{r}{\texttt{amount}} & \arrow{ur}{\texttt{fee} \%} \arrow[rightsquigarrow]{dr}{} & \\
    & & \mathcal{A}[\texttt{to}] \\
\end{tikzcd}

\paragraph{Transfer with guards}
For example, when minting.
\eq{
    \texttt{mint}(\texttt{to}, \texttt{amount}): \\
    \underbrace{\guard}_{\texttt{sender} = \texttt{owner}}
    \mathcal{S}
    \xrightarrow{\texttt{amount}}
    \mathcal{A}[\texttt{to}]
}

\paragraph{Transfer to Timelock}
\[
    \texttt{timeLock}(\texttt{time}, \texttt{from}, \texttt{beneficiary}, \texttt{amount}):
\]
\[
    \mathcal{A}[\texttt{from}]
    \xrightarrow{\texttt{amount}}
    \newc ~ \texttt{Lock}(\texttt{time}, \texttt{beneficiary})
    \rightarrowtail \texttt{locks}
\]

\[
    \texttt{claim}():
\]
\[
    \underbrace{\guard}_{\texttt{sender} = \texttt{beneficiary} ~\texttt{and}~ \texttt{now} > \texttt{time}}
    T(\texttt{time}, \texttt{beneficiary})
    \rightsquigarrow
    \mathcal{A}[\texttt{beneficiary}] \\
\]

\subsection{The DAO attack}
We can prevent the DAO attack (the below is from \url{https://consensys.github.io/smart-contract-best-practices/known_attacks/}):
\begin{lstlisting}
function withdrawBalance() public {
    uint amountToWithdraw = userBalances[msg.sender];
    // At this point, the caller's code is executed, and can call withdrawBalance again
    require(msg.sender.call.value(amountToWithdraw)(""));
    userBalances[msg.sender] = 0;
}
\end{lstlisting}

In \langName, we would write this as:

\begin{lstlisting}
transaction withdrawBalance():
    flow everything from userBalances[msg.sender] to msg.sender.balance
\end{lstlisting}

Not only is this simpler, but the compiler can automatically place the actual call that does the transfer last, meaning that the mistake could simply never be made.

\subsection{approveAndCall}

Many token contracts include the concept of \lstinline{approveAndCall}, typically similarly to the following (taken from: \lstinline{0x174bfa6600bf90c885c7c01c7031389ed1461ab9}, one of the most popular contracts on the blockchain by transaction count):
\begin{lstlisting}
function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, address(this), _extraData);
        return true;
    }
}
\end{lstlisting}

In \langName, we can do the same thing by associating a call with a flow.
\begin{lstlisting}
transaction approveAndCall(_spender : address, _value : uint256, _extraData : bytes):
    consume everything from allowance[msg.sender, _spender]
    flow _value from approvalSource to allowance[msg.sender, _spender],
        then call receiveApproval(msg.sender, _value, address(this), _extraData)
\end{lstlisting}

\paragraph{Nonfungible resources} \`a la ERC-721, but also useful for other things, like accounts.
Saying that something \lstinline{stores account} here means that it stores a set of accounts, because accounts are a nonfungible resource.
\reed{Not sure I like this or if it will be too confusing, but will have to look into this more with more examples and such}
\begin{lstlisting}
resource account := nonfungible address
source accountSource of account

contract FreezeAccounts {
    storage {
        normal stores account
        frozen stores account
    }

    createAccount(addr: address):
        flow addr from accountSource to normal

    freezeAccount(addr: address):
        flow addr from normal to frozen
}
\end{lstlisting}
\reed{I don't think I really like this for managing states.
Will need to work on this more.}

\paragraph{RefundVault}
This is a real example from \lstinline{0xa15c7ebe1f07caf6bff097d8a589fb8ac49ae5b3.sol}.

\begin{lstlisting}
// This should probably be part of the standard library, and not allow the use of "total"
resource ether := fungible nat
resource contract := nonfungible address

source addressSource of address
source initialize of address provides 1

contract RefundVault {
    storage {
        active stores contract
        refunding stores contract
        closed stores contract

        deposited stores ether by address

        wallet stores address
        owner stores address
    }

    on create(wallet_addr) uses sender:
        merge sender into owner
        flow this from initialize to active
        flow wallet_addr from addressSource to wallet

    deposit(investor) has value:
        merge value into deposited[investor]

    close() uses sender:
        only when sender in owner then
            flow this from active to closed,
            and
            merge all in deposited into wallet // Will we be able to optimize this somehow?

    enableRefunds() uses sender:
        only when sender in owner then
            flow this from active to refunding

    refund(investor):
        only when this in refunding then
            merge deposited[investor] into investor
}
\end{lstlisting}

\section{Formalization}

\subsection{Syntax}
\begin{figure}[ht]
\begin{align*}
    C &\in \textsc{ContractNames} & T &\in \textsc{TransactionNames} \\
    I &\in \textsc{InterfaceNames} & S &\in \textsc{StateNames}\\
    D &\in \textsc{ContractNames} \cup \textsc{InterfaceNames} & p &\in \Q \\
    E &\in \textsc{EventNames} & f &\in \textsc{FieldNames} \\
    x &\in \textsc{IdentifierNames} & \mathcal{R} &\in \textsc{ResourceNames} \\
\end{align*}
\caption{Abstract syntax of \langName.}
\label{lang-syntax}
\end{figure}

\reed{Transactions are ``flow graphs'', which perform atomic state updates}
\reed{Asset retentiont theorem?}

\begin{definition}
    A \emph{resource} $\mathcal{R}$ is a tuple $(R, +, 0, \leq, -)$ where
    \begin{enumerate}[label=(\roman*)]
        \item $(R, +, 0)$ is a commutative monoid.
        \item $(R, \leq)$ is a partial order that is compatible with $(R, +, 0)$.
            That is, for any $x, y \in R$ such that $x \leq y$, and for any $z \in R$, we have $x + z \leq y + z$.
        \item $- : R \times R \to R$ is a function so that for any $x,y \in R$ such that $y \leq x$, we have $(x - y) + y = x$.
    \end{enumerate}
    The elements of a resource are called \emph{resource values}.
\end{definition}

\paragraph{Examples}

\begin{enumerate}
    \item The natural numbers with the standard operations is a resource $(\N, +, 0, \leq, -)$, where $-$ is \emph{saturating subtraction}: $n - m = 0$ if $m > n$.
    \item For any set $A$, we can build the resource $(\powerset{A}, \cup, \emptyset, \subseteq, \setminus)$, where $X \setminus Y$ is the set difference operation.
    \item Similarly, given any set $A$, we can build the resource $(\powersetfin{A}, \cup, \emptyset, \subseteq, \setminus)$; this resource is called the \emph{nonfungible resource on $A$}, written $\text{nf}(A)$.
\end{enumerate}

\end{document}

