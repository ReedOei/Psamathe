\documentclass[10pt]{article}

\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{tikz-cd}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bm}
\usepackage{listings}
\usepackage{bbm}
\usepackage{multicol}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{float}
\usepackage[inline]{enumitem}
\usepackage[margin=1.25in]{geometry}
\usepackage[T1]{fontenc}
\usepackage{kpfonts}

\usetikzlibrary{decorations.pathmorphing}

\input{LaTeX/macros.tex}
\input{macros.tex}

\newcommand{\putS}{\textbf{\texttt{put}}\xspace}
\newcommand{\evaluates}{\to}
\newcommand{\compat}{\text{compat}\xspace}
\newcommand{\resolve}{\textbf{\texttt{resolve}}\xspace}
\newcommand{\values}{\text{values}\xspace}
\newcommand{\loc}{\text{loc}\xspace}

\begin{document}

\section{Formalization}

\subsection{Locators}

\begin{tabular}{l r l l}
    $\mathcal{L}$ & \bnfdef & $x$ \bnfalt $\var~x : T$ \bnfalt $\mathcal{L} \to @x$ \bnfalt $[ \overline{\mathcal{L}} ]$ \bnfalt $\{ \overline{x : \tau \mapsto \mathcal{L}} \}$ \bnfalt $\mathcal{L} \sends{\mathcal{L}}$ \bnfalt $\mathcal{L} \sends{\mathcal{Q} \tsuchthat f[\overline{T}](\overline{L})}$ & (locators) \\
    Flow & \bnfdef & $\mathcal{L} \to \mathcal{L}$ \bnfalt $\mathcal{L} \to f[\overline{T}](\overline{x}) \to \mathcal{L}$ & (flows) \\
\end{tabular}

\begin{mathpar}
    \inferrule*[right=Loc-Id]{
    }{ \angles{ \Sigma, x } \to \angles{ \Sigma, \mu(x) } }

    \inferrule*[right=Loc-VarDef]{
        \ell \not\in \dom(\rho)
    }{ \angles{ \Sigma, \var~x : T } \to \angles{ \Sigma[\mu \mapsto \mu[x \mapsto \ell], \rho \mapsto \rho[\ell \mapsto []]], \ell } }

    \inferrule*[right=Loc-Field-Congr]{
        \angles{ \Sigma, \mathcal{L} } \to \angles{ \Sigma', \mathcal{L}' }
    }{ \angles{ \Sigma, \mathcal{L} \to @x } \to \angles{ \Sigma', \mathcal{L}' \to @x } }

    \inferrule*[right=Loc-Field]{
        \overline{\rho(\ell).x = k}
    }{ \angles{ \Sigma, \overline{\ell} \to @x } \to \angles{ \Sigma', \overline{k} } }

    \inferrule*[right=Loc-List-Congr]{
        \angles{ \Sigma, \mathcal{L} } \to \angles{ \Sigma', \mathcal{L}' }
    }{ \angles{ \Sigma, [ \overline{\ell}, \mathcal{L}, \overline{\mathcal{L}'} ] } \to \angles{ \Sigma', [ \overline{\ell}, \mathcal{L}', \overline{\mathcal{L}'} ] } }

    \inferrule*[right=Loc-List]{
        k \not\in \dom(\rho)
    }{ \angles{ \Sigma, [ \overline{\ell} ] } \to \angles{ \Sigma[\rho \mapsto \rho[k \mapsto \overline{\ell}]] , k } }

    \inferrule*[right=Loc-Val-Src-Congr]{
        \angles{ \Sigma, \mathcal{L} } \to \angles{ \Sigma'', \mathcal{L}'' }
    }{ \angles{ \Sigma, \mathcal{L} \sends{\mathcal{L}'} } \to \angles{ \Sigma'', \mathcal{L}'' \sends{\mathcal{L}'} } }

    \inferrule*[right=Loc-Val-Sel-Congr]{
        \angles{ \Sigma, \mathcal{L}' } \to \angles{ \Sigma'', \mathcal{L}'' }
    }{ \angles{ \Sigma, \ell \sends{\mathcal{L}'} } \to \angles{ \Sigma'', \ell \sends{\mathcal{L}'} } }

    \inferrule*[right=Loc-Val]{
    }{ \angles{ \Sigma, \overline{\ell} \sends{\overline{k}} } \to \angles{ \Sigma, \select(\rho, \overline{\ell}, \overline{k}) } }

    % \inferrule*[right=Loc-Filter]{
    %     y \not\in \dom(\mu)
    %     \\
    %     \overline{j} = [ k \in \overline{\ell} : \angles{ \Sigma, f(\overline{x}, y) } \to^* \angles{ \Sigma
    % }{ \angles{ \Sigma, \overline{\ell} \sends{\mathcal{Q}~\tsuchthat~f(\overline{x},  @x } \to \angles{ \Sigma', \mathcal{L}' \to @x } }
\end{mathpar}

\[
    \select(\rho, \overline{\ell}, \overline{k}) =
    \begin{cases}
        [] & \tif \overline{k} = [] \\
        \revert & \tif \overline{\ell} = [] \tand \overline{k} \neq [] \\
        j, \select(\rho, \overline{\ell} \setminus j, \overline{k'}) & \tif \overline{k} = (i, \overline{k'}) \tand j \in \overline{\ell} \tand \rho(i) = \rho(j) \\
        \select(\rho, \overline{\ell}, \overline{k'}) & \tif \overline{k} = (i, \overline{k'}) \tand \forall j \in \overline{\ell}. \rho(i) \neq \rho(j) \\
        % \select(\overline{\ell'}, \overline{k'})
    \end{cases}
\]

\subsection{Syntax}
\begin{align*}
    f &\in \textsc{TransformerNames} & t &\in \textsc{TypeNames} \\
    a,x,y,z &\in \textsc{Identifiers} & \alpha, \beta &\in \textsc{TypeVariables} \\
\end{align*}
\begin{tabular}{l r l l}
    $\mathcal{Q}$, $\mathcal{R}$, $\mathcal{S}$ & \bnfdef & $\exactlyone$ \bnfalt $\any$ \bnfalt $\nonempty$ \bnfalt $\emptyq$ \bnfalt $\every$ & (type quantities) \\
    $M$ & \bnfdef & \fungible \bnfalt \unique \bnfalt \immutable \bnfalt \consumable \bnfalt \asset & (type declaration modifiers) \\
    $T$ & \bnfdef & $\boolt$ \bnfalt $\natt$ \bnfalt $\alpha$ \bnfalt $\type~t[\overline{T_V}]~\is~\overline{M}~T$ \bnfalt $\listq~\tau$ \bnfalt $\{ \overline{x : \tau} \}$ & (base types) \\
    $\tau$, $\sigma$, $\pi$ & \bnfdef & $\mathcal{Q}~T$ & (types) \\
    $T_V$ & \bnfdef & $\alpha~\is~\overline{M}$ & (type variable declaration) \\
    $\mathcal{S}$ & \bnfdef & $x$ \bnfalt $x.y$ \bnfalt $\true$ \bnfalt $\false$ \bnfalt $n$ \bnfalt $\demote(x)$ \bnfalt $[x]$ \bnfalt $\{ \overline{x : \tau \mapsto x} \}$ \bnfalt $\newc(t, \overline{M}, T)$ & (sources) \\
    $\mathcal{D}$ & \bnfdef & $x$ \bnfalt $x.y$ \bnfalt $\var~x:T$ \bnfalt $\consume$ & (destinations) \\
    $\Decl$ & \bnfdef & $\transformer~f[\overline{T_V}](\overline{x : \tau}) \to x : \tau ~\{ \overline{\Stmt} \}$ & (transformers) \\
    $\Stmt$ & \bnfdef & $\mathcal{S} \to \mathcal{D}$ \bnfalt $\mathcal{S} \sends{x} \mathcal{D}$ \bnfalt $\mathcal{S} \sends{\mathcal{Q}~\suchthat~f[\overline{T}](\overline{x})} \mathcal{D}$ \bnfalt $\mathcal{S} \to f[\overline{T}](\overline{x}) \to \mathcal{D}$ & (flows) \\
            & \bnfalt & $\tryS~\{ \overline{\Stmt} \}~\catchS~\{ \overline{\Stmt} \}$ & (try-catch) \\
    $\Prog$ & \bnfdef & $\overline{\Decl}; \overline{\Stmt}$ & (programs)
\end{tabular}

\subsection{Statics}

\framebox{$\Gamma \flowproves \mathcal{S} : \tau \flowprovesout \Delta$}
\framebox{$\Gamma \flowproves \mathcal{D} : \tau \flowprovesout \Delta$} \textbf{Storage Typing}

A \emph{storage} is either a source or a destination.

\begin{mathpar}
    \inferrule*[right=Bool]{
        b \in \{ \true, \false \}
    }{ \Gamma \flowproves b : \,\,\exactlyone~\boolt \flowprovesout \Gamma }

    \inferrule*[right=Nat]{
    }{ \Gamma \flowproves n : \,\,\exactlyone~\natt \flowprovesout \Gamma }

    \inferrule*[right=Demote]{
    }{ \Gamma, x : \tau \flowproves \demote(x) : \demoteT(\tau) \flowprovesout \Gamma, x : \tau }

    \inferrule*[right=Var]{
        \immutable \not\in \modifiers(\tau)
    }{ \Gamma, x : \tau \flowproves x : \tau \flowprovesout \Gamma, x : \tau }

    \inferrule*[right=Field]{
        \Gamma \flowproves x : \,\,\exactlyone~T \flowprovesout \Delta
        \\
        \immutable \not\in \modifiers(\tau)
        \\
        \fields(T) = \overline{z : \sigma}
        \\
        y : \tau \in \overline{z : \sigma}
    }{ \Gamma \flowproves x.y : \tau \flowprovesout \Gamma }

    \inferrule*[right=Single]{
    }{ \Gamma, x : \mathcal{Q}~T \flowproves [x] : \,\,\exactlyone~\listq~\mathcal{Q}~T \flowprovesout \Gamma, x : \emptyq~T }

    \inferrule*[right=Record]{
    }{ \Gamma, \overline{y : \mathcal{Q}~T} \flowproves \{ \overline{x : \mathcal{Q}~T \mapsto y} \} : \,\,\exactlyone~\{ \overline{x : \mathcal{Q}~T} \} \flowprovesout \Gamma, \overline{y : \emptyq~T} }

    \inferrule*[right=New]{
    }{ \Gamma \flowproves \newc(t, \overline{M}, T) : \every~\listq~\exactlyone~(\type~t~\is~\overline{M}~T) \flowprovesout \Gamma }

    \inferrule*[right=VarDef]{
    }{ \Gamma \flowproves (\var~x : T) : \emptyq~T \flowprovesout \Gamma, x : \emptyq~T }

    \inferrule*[right=Consume]{
        \tau~\consumable
    }{ \Gamma \flowproves \consume : \tau \flowprovesout \Gamma }
\end{mathpar}

\framebox{$\Gamma \flowproves S~\ok \flowprovesout \Delta$} \textbf{Statement Well-formedness}
\begin{mathpar}
    \inferrule*[right=Ok-Flow-Every]{
        \Gamma \flowproves \mathcal{S} : \mathcal{Q}~T \flowprovesout \Delta
        \\
        \update(\Delta, \mathcal{S}, \Delta(\mathcal{S}) \ominus \mathcal{Q}) \flowproves \mathcal{D} : \mathcal{R}~T \flowprovesout \Xi
    }{ \Gamma \flowproves (\mathcal{S} \to \mathcal{D})~\ok \flowprovesout \update(\Xi, \mathcal{D}, \Xi(\mathcal{D}) \oplus \mathcal{Q}) }

    \inferrule*[right=Ok-Flow-Var]{
        \Gamma \flowproves \mathcal{S} : \mathcal{Q}~T \flowprovesout \Delta
        \\
        \Delta \flowproves x : \demoteT(\mathcal{R}~T) \flowprovesout \Delta
        \\
        \update(\Delta, \mathcal{S}, \Delta(\mathcal{S}) \ominus \mathcal{Q}) \flowproves \mathcal{D} : \mathcal{S}~T \flowprovesout \Xi
    }{ \Gamma \flowproves (\mathcal{S} \sends{x} \mathcal{D})~\ok \flowprovesout \update(\Xi, \mathcal{D}, \Xi(\mathcal{D}) \oplus \mathcal{R}) }

    \inferrule*[right=Ok-Flow-Filter]{
        \Gamma \flowproves \mathcal{S} : \mathcal{Q}~T \flowprovesout \Delta
        \\
        % \transformer~f(\overline{x : \sigma}, y : \demoteT(\elemtype(T))) \to z : \,\,!~\boolt ~\{~\overline{\Stmt}~\}
        \typeof(f, \overline{T}) = (\overline{x : \sigma}, y : \demoteT(\elemtype(T))) \to z : \,\,!~\boolt
        \\
        \forall i. \demoteT(\Gamma(a_i)) = \sigma_i
        \\
        \update(\Delta, \mathcal{S}, \Delta(\mathcal{S}) \ominus \mathcal{Q}) \flowproves \mathcal{D} : \mathcal{S}~T \flowprovesout \Xi
    }{ \Gamma \flowproves (\mathcal{S} \sends{\mathcal{R}~\suchthat~f[\overline{T}](\overline{a})} \mathcal{D})~\ok \flowprovesout \update(\Xi, \mathcal{D}, \Xi(\mathcal{D}) \oplus \min(\mathcal{Q}, \mathcal{R})) }

    \inferrule*[right=Ok-Flow-Transformer]{
        \Gamma \flowproves \mathcal{S} : \mathcal{Q}~T_1 \flowprovesout \Delta
        \\
        % \transformer~f(\overline{x : \sigma}, y : \elemtype(T_1)) \to z : \mathcal{R}~T_2~\{~ \overline{\Stmt} ~\}
        \typeof(f, \overline{T}) = (\overline{x : \sigma}, y : \elemtype(T_1)) \to z : \mathcal{R}~T_2~\{~ \overline{\Stmt} ~\}
        \\
        \forall i. \demoteT(\Gamma(x_i)) = \sigma_i
        \\
        \update(\Delta, \mathcal{S}, \Delta(\mathcal{S}) \ominus \mathcal{Q}) \flowproves \mathcal{D} : \mathcal{S}~T_2 \flowprovesout \Xi
    }{ \Gamma \flowproves (\mathcal{S} \to f[\overline{T}](\overline{x}) \to \mathcal{D})~\ok \flowprovesout \update(\Xi, \mathcal{D}, \Xi(\mathcal{D}) \oplus \mathcal{Q}) }

    \inferrule*[right=Ok-Try]{
        \Gamma \flowproves \overline{S_1}~\ok \flowprovesout \Delta
        \\
        \Gamma \flowproves \overline{S_2}~\ok \flowprovesout \Xi
    }{ \Gamma \flowproves (\tryS~\{ \overline{S_1} \}~\catchS~\{ \overline{S_2} \})~\ok \flowprovesout \Delta \sqcup \Xi }
\end{mathpar}

\framebox{$\proves \Decl~\ok$} \textbf{Declaration Well-formedness}
\begin{mathpar}
    \inferrule*[right=Ok-Transformer]{
        \overline{T_V}, \overline{x : \tau} \flowproves \overline{\Stmt}~\ok \flowprovesout \Gamma, y : \sigma
        \\
        \forall \pi \in \img(\Gamma). \lnot\isAsset(\overline{T_V}, \pi)
    }{ \proves (\transformer~f[\overline{T_V}](\overline{x : \tau}) \to y : \sigma \{ \overline{\Stmt} \})~\ok }
\end{mathpar}

\framebox{$\Prog~\ok$} \textbf{Program Well-formedness}
\begin{mathpar}
    \inferrule*[right=Ok-Prog]{
        \proves \overline{\Decl}~\ok
        \\
        \emptyset \flowproves \overline{\Stmt}~\ok \flowprovesout \Gamma
        \\
        \forall \tau \in \img(\Gamma). \lnot \isAsset(\emptyset, \tau)
    }{ (\overline{\Decl}; \overline{\Stmt})~\ok }
\end{mathpar}

\subsection{Dynamics}
\begin{tabular}{l r l l}
    $V$ & \bnfdef & $\true$ \bnfalt $\false$ \bnfalt $n$ \bnfalt $\{ \overline{x : \tau \mapsto \N} \}$ & \\
    $\mathcal{V}$ & \bnfdef & $\overline{V}$ & \\
    $\Stmt$ & \bnfdef & $\ldots$ \bnfalt $\putS(\mathcal{V}, \mathcal{D})$ \bnfalt $\revert$ \bnfalt $\tryS(\Sigma, \overline{\Stmt}, \overline{\Stmt})$ & \\
\end{tabular}

\begin{definition}
    An environment $\Sigma$ is a tuple $(\mu, \rho)$ where $\mu : \textsc{IdentifierNames} \partialfunc \mathbb{N}$ is the \emph{variable lookup environment}, and $\rho : \mathbb{N} \partialfunc \mathcal{V}$ is the \emph{storage environment}.
\end{definition}

\framebox{$\angles{\Sigma, \overline{\Stmt}} \to \angles{\Sigma, \overline{\Stmt}}$}

Note that we abbreviate $\angles{\Sigma, \cdot}$ as $\Sigma$, which signals the end of evaluation.

The new constructs of $\resolve(\Sigma, \mathcal{S})$ and $\putS(\mathcal{V}, \mathcal{D})$ are used to simplify the process of locating sources and updating destinations, respectively.
\reed{Can probably just make put into a function as well, like resolve.}

\begin{mathpar}
    \inferrule*[right=Seq]{
        % S_1 \neq \tryS~\{ \overline{S_4} \}~\catchS~\{ \overline{S_5} \}
        % \\
        \angles{\Sigma, S_1 } \to \angles{\Sigma', \overline{S_3}}
    }{ \angles{\Sigma, S_1 \overline{S_2}} \to \angles{\Sigma', \overline{S_3}~\overline{S_2}} }

    \inferrule*[right=Revert]{
    }{ \angles{ \Sigma, (\revert)~\overline{S} } \to \angles{ \Sigma, \revert } }
\end{mathpar}

Here we give the rules for the new $\putS(\mathcal{V}, \mathcal{D})$ statement.
Here $\mathcal{V} + \mathcal{W}$ refers to the combine operation for relevant values.
\reed{TODO: Need to finalize how $\mathcal{V} + \mathcal{W}$ works; in particular, need to make sure that you can't overwrite things that shouldn't be overwritten (e.g., a nonfungible nat).
Probably need to tag types with modifiers or something.}
\reed{Here we have an issue if we want to do this thing that actually allows working with infinite lists/sets of values, because we can't concatenate two infintie lists (or at least, I'm not sure how...).
But we could use multisets and dodge all the issues (also resolves the issue of how to deal with duplicates).}

\begin{mathpar}
    \inferrule*[right=Put-Consume]{
    }{ \angles{\Sigma, \putS(\mathcal{V}, \consume)} \evaluates \Sigma }

    \inferrule*[right=Put-Var]{
    }{ \angles{ \Sigma, \putS(\mathcal{V}, x) } \evaluates \angles{ \Sigma, \putS(\mathcal{V}, \mu(x)) } }

    \inferrule*[right=Put-Field]{
        \rho(\mu(X)) = \{ \overline{x : \tau \mapsto \ell} \}
        \\
        (y : \sigma \mapsto k) \in \overline{x : \tau \mapsto \ell}
    }{ \angles{ \Sigma, \putS(\mathcal{V}, x.y) } \evaluates \angles{ \Sigma, \putS(\mathcal{V}, k) } }

    \inferrule*[right=Put-Loc]{
        \rho(\ell) = \mathcal{W}
        \\
        \mathcal{W} + \mathcal{V} \neq \revert
    }{ \angles{ \Sigma, \putS(\mathcal{V}, \ell) } \evaluates \Sigma[\rho \mapsto \rho[\ell \mapsto \mathcal{W} + \mathcal{V}]] }

    \inferrule*[right=Put-Loc-Fail]{
        \rho(\ell) = \mathcal{W}
        \\
        \mathcal{W} + \mathcal{V} = \revert
    }{ \angles{ \Sigma, \putS(\mathcal{V}, \ell) } \evaluates \angles{\Sigma, \revert} }

    \inferrule*[right=Put-VarDef]{
        \ell \not\in \dom(\rho)
    }{ \angles{ \Sigma, \putS(\mathcal{V}, \var~A : T) } \evaluates \Sigma[\mu \mapsto \mu[A \mapsto \ell], \rho \mapsto \rho[\ell \mapsto \mathcal{V}]] }
\end{mathpar}

\begin{mathpar}
    \inferrule*[right=Flow-Every]{
        \resolve(\Sigma, \mathcal{S}) = (\Sigma', \ell)
    }{ \angles{\Sigma, \mathcal{S} \to \mathcal{D}} \evaluates \angles{\Sigma'[\rho \mapsto \rho'[\ell \mapsto []]], \putS(\rho'(\ell), \mathcal{D}) } }

    \inferrule*[right=Flow-Var]{
        \resolve(\Sigma, \mathcal{S}) = (\Sigma', \ell)
        \\
        \rho'(\ell) = \mathcal{V}
        \\
        \rho'(\mu'(x)) = \mathcal{W}
        \\
        \mathcal{W} \leq \mathcal{V}
    }{ \angles{\Sigma, \mathcal{S} \sends{x} \mathcal{D}} \evaluates \angles{\Sigma'[\rho \mapsto \rho'[\ell \mapsto \mathcal{V} - \mathcal{W}]], \putS(\mathcal{W}, \mathcal{D}) } }

    \inferrule*[right=Flow-Var-Fail]{
        \resolve(\Sigma, \mathcal{S}) = (\Sigma', \ell)
        \\
        \rho'(\ell) = \mathcal{V}
        \\
        \rho'(\mu'(x)) = \mathcal{W}
        \\
        \mathcal{W} \not\leq \mathcal{V}
    }{ \angles{\Sigma, \mathcal{S} \sends{x} \mathcal{D}} \evaluates \angles{ \Sigma', \revert } }

    \inferrule*[right=Flow-Filter]{
        \resolve(\Sigma, \mathcal{S}) = (\Sigma', \ell)
        \\
        \rho'(\ell) = \mathcal{V}
        \\
        \mathcal{U} = [ v \in \mathcal{V} ~|~ \angles{\Sigma', f(\overline{x}, v)} \to^* \angles{\Sigma'', k} \tand \rho''(k) = \true ]
        \\
        \compat(|\mathcal{U}|, |\mathcal{V}|, \mathcal{Q})
    }{ \angles{ \Sigma, \mathcal{S} \sends{\mathcal{Q}~\suchthat~f(\overline{x})} \mathcal{D} } \evaluates \angles{ \Sigma'[\rho' \mapsto \rho'[\ell \mapsto \rho'(\ell) - \mathcal{U}]], \putS(\mathcal{U}, \mathcal{D}) } }

    \inferrule*[right=Flow-Filter-Fail]{
        \resolve(\Sigma, \mathcal{S}) = (\Sigma', \ell)
        \\
        \rho'(\ell) = \mathcal{V}
        \\
        \mathcal{U} = [ v \in \mathcal{V} ~|~ \angles{\Sigma', f(\overline{x}, v)} \to^* \angles{\Sigma'', k} \tand \rho''(k) = \true ]
        \\
        \lnot \compat(|\mathcal{U}|, |\mathcal{V}|, \mathcal{Q})
    }{ \angles{ \Sigma, \mathcal{S} \sends{\mathcal{Q}~\suchthat~f(\overline{x})} \mathcal{D} } \evaluates \angles{ \Sigma', \revert } }

    \inferrule*[right=Flow-Transformer]{
        \resolve(\Sigma, \mathcal{S}) = (\Sigma', \ell)
        \\
        \rho'(\ell) = v, \mathcal{V}
        \\
        \angles{ \Sigma'[\rho \mapsto \rho'[\ell \mapsto \mathcal{V}]], f(\overline{x}, v) } \to^* \angles{ \Sigma'', k }
    }{ \angles{\Sigma, \mathcal{S} \to f(\overline{x}) \to \mathcal{D}} \evaluates \angles{ (\mu', \rho''), \putS([ \rho''(k) ], \mathcal{D}) ~ (\mathcal{S} \to f(\overline{x}) \to \mathcal{D}) } }

    \inferrule*[right=Flow-Transformer-Done]{
        \resolve(\Sigma, \mathcal{S}) = (\Sigma', \ell)
        \\
        \rho'(\ell) = []
    }{ \angles{ \Sigma, \mathcal{S} \to f(\overline{x}) \to \mathcal{D} } \evaluates \angles{ \Sigma, \putS([], \mathcal{D}) } }
\end{mathpar}

\reed{NOTE: It is important that we flow an empty list in the \textsc{Flow-Transformer-Done} rule, otherwise we may fail to allocate a variable as expected.}

\begin{mathpar}
    \inferrule*[right=Call]{
        \ell \not\in \dom(\rho)
        \\
        \transformer~f(\overline{y : \tau}) \to z : \sigma~\{~\overline{S}~\}
        \\
        \mu' = \overline{y \mapsto \mu(x)}, z \mapsto \ell
    }{ \angles{ \Sigma, f(\overline{x}) } \evaluates \angles{ (\mu', \rho[\ell \mapsto []]), \overline{S}~\ell } }
\end{mathpar}

We introduce a new statement, $\tryS(\Sigma, \overline{S_1}, \overline{S_2})$, to implement the try-catch statement, which keeps track of the environment that we begin execution in so that we can revert to the original environment in the case of a $\revert$.

\begin{mathpar}
    \inferrule*[right=Try-Start]{
    }{ \angles{ \Sigma, \tryS~\{ \overline{S_1} \}~\catchS~\{ \overline{S_2} \} } \evaluates \angles{ \Sigma, \tryS(\Sigma, \overline{S_1}, \overline{S_2}) } }

    \inferrule*[right=Try-Step]{
        \angles{ \Sigma, \overline{S_1} } \evaluates \angles{ \Sigma'', \overline{S_1'} }
    }{ \angles{ \Sigma, \tryS(\Sigma', \overline{S_1}, \overline{S_2}) } \evaluates \angles{ \Sigma'', \tryS(\Sigma', \overline{S_1'}, \overline{S_2}) } }

    \inferrule*[right=Try-Revert]{
    }{ \angles{ \Sigma, \tryS(\Sigma', \revert, \overline{S_2}) } \evaluates \angles{ \Sigma', \overline{S_2}} }

    \inferrule*[right=Try-Done]{
    }{ \angles{ \Sigma, \tryS(\Sigma', \cdot, \overline{S_2}) } \evaluates \Sigma }
\end{mathpar}

\framebox{$\resolve(\Sigma, \mathcal{S}) = (\Sigma', \ell)$} \textbf{Storage Resolution}

We use $\resolve(\Sigma, \mathcal{S})$ to get the location storing the values of $\mathcal{S}$, which returns an environment because it may need to allocate new memory (e.g., in the case of creating a new record value).

\begin{mathpar}
    \inferrule*[right=Resolve-Var]{
        \mu(\mathcal{S}) = \ell
    }{ \resolve(\Sigma, \mathcal{S}) = (\Sigma, \ell) }

    \inferrule*[right=Resolve-Field]{
        \rho(\mu(x)) = \{ \overline{z : \tau \mapsto \ell} \}
        \\
        (y : \sigma \mapsto k) \in \overline{z : \tau \mapsto \ell}
    }{ \resolve(\Sigma, x.y) = (\Sigma, k) }

    \inferrule*[right=Resolve-Single]{
        \ell \not\in \dom(\rho)
    }{ \resolve(\Sigma, [ x ]) = (\Sigma[\rho \mapsto \rho[\ell \mapsto \rho(\mu(x)), \mu(x) \mapsto []]], \ell) }

    \inferrule*[right=Resolve-Record]{
        \overline{\ell \not\in \dom(\rho)}
        \\
        k \not\in \dom(\rho) \cup \overline{\ell}
        \\
        \Sigma' = \Sigma[\rho \mapsto \rho[\overline{\mu(y) \mapsto []}, \overline{\ell \mapsto \rho(\mu(y))}, k \mapsto \{ \overline{x : \tau \mapsto \ell} \} ]]
    }{ \resolve(\Sigma, \{ \overline{x : \tau \mapsto y} \}) = (\Sigma', k) }

    \inferrule*[right=Resolve-Bool]{
        b \in \{ \true, \false \}
        \\
        \ell \not\in \dom(\rho)
    }{ \resolve(\Sigma, b) = (\Sigma[\rho \mapsto \rho[\ell \mapsto b]], \ell) }

    \inferrule*[right=Resolve-Nat]{
        \ell \not\in \dom(\rho)
    }{ \resolve(\Sigma, n) = (\Sigma[\rho \mapsto \rho[\ell \mapsto n]], \ell) }

    \inferrule*[right=Resolve-Source]{
        \mu(t) = \ell
    }{ \resolve(\Sigma, \newc(t, \overline{M}, T)) = (\Sigma, \ell) }

    \inferrule*[right=Resolve-New-Source]{
        t \not\in \dom(\mu)
        \\
        \ell \not\in \dom(\rho)
    }{ \resolve(\Sigma, \newc(t, \overline{M}, T)) = (\Sigma'[\rho \mapsto \rho[\ell \mapsto \values(T)], \mu \mapsto \mu[t \mapsto \ell]], \ell) }
\end{mathpar}

\reed{TODO: Need to be sure to handle uniqueness correctly; could do this in \textsc{Resolve-New-Source}, or in the various flow rules.}

\subsection{Auxiliaries}
\begin{definition}
    Define $\Quant = \curlys{\emptyq, \any, \exactlyone, \nonempty, \every}$, and call any $\mathcal{Q} \in \Quant$ a \emph{type quantity}.
    Define $\emptyq < \any < \,\, \exactlyone < \nonempty < \every$.
\end{definition}

\framebox{$\isAsset(\overline{T_V}, \tau)$} \textbf{Asset Types}

\begin{align*}
    \isAsset(\overline{T_V}, \mathcal{Q}~T) \iff \mathcal{Q} \neq \emptyq \tand (& \asset \in \modifiers(\overline{T_V}, T) \tor \\
                                                                                 & (T = \mathcal{C}~\tau \tand \isAsset(\overline{T_V}, \tau)) \tor \\
                                                                                 & (T = \curlys{\overline{y : \sigma}} \tand \exists x : \tau \in \overline{y : \sigma}. \isAsset(\overline{T_V}, \tau)) \tor \\
\end{align*}
% \reed{It should be the case that a transformer can have an output of an asset type if and only if it has an input asset type (and it the case of curried transformers, that \textbf{some} input type is an asset).}

\framebox{$\tau~\consumable$} \textbf{Consumable Types}
\begin{align*}
    (\mathcal{Q}~T)~\consumable \iff &\consumable \in \modifiers(T) \tor \\
                                     &\lnot((\mathcal{Q}~T)~\asset) \tor \\
                                     &(T = \mathcal{C}~\tau \tand \tau~\consumable) \tor \\
                                     &(T = \curlys{\overline{y : \sigma}} \tand \forall x : \tau \in \overline{y : \sigma}. (\sigma~\consumable))
\end{align*}

$\mathcal{Q} \oplus \mathcal{R}$ represents the quantity present when flowing $\mathcal{R}$ of something to a storage already containing $\mathcal{Q}$.
$\mathcal{Q} \ominus \mathcal{R}$ represents the quantity left over after flowing $\mathcal{R}$ from a storage containing $\mathcal{Q}$.

\begin{definition}
    Let $\mathcal{Q}, \mathcal{R} \in \Quant$.
    Define the commutative operator $\oplus$, called \emph{combine}, as the unique function $\Quant^2 \to \Quant$ such that
    \[
        \renewcommand\arraystretch{1.2}
        \begin{array}{r c l l l}
            \mathcal{Q} \oplus \emptyq & = & \mathcal{Q} & \\
            \mathcal{Q} \oplus \every & = & \every & \\
            \nonempty \oplus \mathcal{R} & = & \nonempty & \tif \emptyq < \mathcal{R} < \every \\
            \exactlyone \oplus \mathcal{R} & = & \nonempty & \tif \emptyq < \mathcal{R} < \every \\
            \any \oplus \any & = & \any &
        \end{array}
    \]

    Define the operator $\ominus$, called \emph{split}, as the unique function $\Quant^2 \to \Quant$ such that
    \[
        \renewcommand\arraystretch{1.2}
        \begin{array}{r c l l l}
            \mathcal{Q} \ominus \emptyq & = & \mathcal{Q} & \\
            \emptyq \ominus \mathcal{R} & = & \emptyq & \\
            \mathcal{Q} \ominus \every &= & \emptyq & \\
            \every \ominus \mathcal{R} &= & \every & \tif \mathcal{R} < \every \\
            \nonempty - \mathcal{R} &= & \any & \tif \emptyq < \mathcal{R} < \every \\
            \exactlyone - \mathcal{R} &= & \emptyq & \tif \exactlyone \leq \mathcal{R} \\
            \exactlyone - \any &= & \any & \\
            \any - \mathcal{R} &= & \any & \tif \emptyq < \mathcal{R} < \every \\
        \end{array}
    \]
\end{definition}

Note that we write $(\mathcal{Q}~T) \oplus \mathcal{R}$ to mean $(\mathcal{Q} \oplus \mathcal{R})~T$ and similarly $(\mathcal{Q}~T) \ominus \mathcal{R}$ to mean $(\mathcal{Q} \ominus \mathcal{R})~T$.

\begin{definition}
    We can consider a type environment $\Gamma$ as a function $\textsc{Identifiers}\xspace \to \textsc{Types}\xspace \cup \curlys{\bot}$ as follows:
    \[
        \Gamma(x) =
        \begin{cases}
            \tau & \tif x : \tau \in \Gamma \\
            \bot & \owise
        \end{cases}
    \]
    We write $\dom(\Gamma)$ to mean $\setbuild{x \in \textsc{Identifiers}}{\Gamma(x) \neq \bot}$, and $\Gamma|_X$ to mean the environment $\setbuild{x : \tau \in \Gamma}{x \in X}$ (restricting the domain of $\Gamma$).
\end{definition}

\begin{definition}
    Let $\mathcal{Q}$ and $\mathcal{R}$ be \typeQuantities, $T_\mathcal{Q}$ and $T_\mathcal{R}$ base types, and $\Gamma$ and $\Delta$ type environments.
    Define the following orderings, which make types and type environments into join-semilattices.
    For type quantities, define the partial order $\sqsubseteq$ as the reflexive closure of the strict partial order $\sqsubset$ given by
    \[
        \mathcal{Q} \sqsubset \mathcal{R} \iff (\mathcal{Q} \neq \any \tand \mathcal{R} = \any) \tor (\mathcal{Q} \in \curlys{\exactlyone, \every} \tand \mathcal{R} = \nonempty)
    \]
    For types, define the partial order $\leq$ by
    \[
        \mathcal{Q}~T_\mathcal{Q} \leq \mathcal{R}~T_\mathcal{R} \iff T_\mathcal{Q} = T_\mathcal{R} \tand \mathcal{Q} \sqsubseteq \mathcal{R}
    \]
    For type environments, define the partial order $\leq$ by
    \[
        \Gamma \leq \Delta \iff \forall x. \Gamma(x) \leq \Delta(x)
    \]
    Denote the join of $\Gamma$ and $\Delta$ by $\Gamma \sqcup \Delta$.
\end{definition}

\framebox{$\elemtype(T) = \tau$}
\begin{align*}
    \elemtype(T) =
    \begin{cases}
        \elemtype(T') & \tif T = \type~t~\is~\overline{M}~T' \\
        \tau & \tif T = \mathcal{C}~\tau \\
        !~T & \owise
    \end{cases}
\end{align*}

\framebox{$\modifiers(\overline{T_V}, T) = \overline{M}$} \textbf{Type Modifiers}
\begin{align*}
    \modifiers(\overline{T_V}, T) =
    \begin{cases}
        \overline{M} & \tif T = \type~t~\is~\overline{M}~T' \\
        \overline{M} & \tif (T~\is~\overline{M}) \in \overline{T_V} \\
        \emptyset & \owise
    \end{cases}
\end{align*}

\framebox{$\demoteT(\tau) = \sigma$}
\framebox{$\demoteT_*(T_1) = T_2$} \textbf{Type Demotion}
$\demoteT$ and $\demoteT_*$ take a type and ``strip'' all the asset modifiers from it, as well as unfolding named type definitions.
This process is useful, because it allows selecting asset types without actually having a value of the desired asset type.
Note that demoting a transformer type changes nothing.
This is because a transformer is \textbf{never} an asset, regardless of the types that it operators on, because it has no storage.

\begin{align*}
    \demoteT(\mathcal{Q}~T) &= \mathcal{Q}~\demoteT_*(T) \\
    \demoteT_*(\boolt) &= \boolt \\
    \demoteT_*(\natt) &= \natt \\
    \demoteT_*(\curlys{\overline{x : \tau}}) &= \curlys{\overline{x : \demoteT(\tau)}} \\
    \demoteT_*(\type~t~\is~\overline{M}~T) &= \demoteT_*(T)
\end{align*}

\framebox{$\fields(T) = \overline{x : \tau}$} \textbf{Fields}
\begin{align*}
    \fields(T) =
    \begin{cases}
        \overline{x : \tau} & \tif T = \{ \overline{x : \tau} \} \\
        \fields(T) & \tif T = \type~t~\is~\overline{M}~T \\
        \emptyset & \owise
    \end{cases}
\end{align*}

\framebox{$\update(\Gamma, x, \tau)$} \textbf{Type environment modification}
\[
    \update(\Gamma, x, \tau) =
    \begin{cases}
        \Delta, x : \tau & \tif \Gamma = \Delta, x : \sigma \\
        \Gamma & \owise
    \end{cases}
\]

\framebox{$\compat(n, m, \mathcal{Q})$}
The relation $\compat(n, m, \mathcal{Q})$ holds when the number of values sent, $n$, is compatible with the original number of values $m$, and the type quantity used, $\mathcal{Q}$.

\begin{align*}
    \compat(n, m, \mathcal{Q}) \iff & (\mathcal{Q} = \nonempty \tand n \geq 1) \tor \\
                                    & (\mathcal{Q} = \,\,\exactlyone \tand n = 1) \tor \\
                                    & (\mathcal{Q} = \emptyq \tand n = 0) \tor \\
                                    & (\mathcal{Q} = \every \tand n = m) \tor \\
                                    & \mathcal{Q} = \any
\end{align*}

\framebox{$\values(T) = \mathcal{V}$}
The function $\values$ gives a list of all of the values of a given base type.

\begin{align*}
    \values(\boolt) & = [ \true, \false ] \\
    \values(\natt) & = [ 0, 1, 2, \ldots ] \\
    \values(\listq~T) & = [ L | L \subseteq \values(T), |L| < \infty ] \\
    \values(\type~t~\is~\overline{M}~T) &= \values(T) \\
    \values(\{ \overline{x : \mathcal{Q}~T} \}) &= [ \{ \overline{x : \tau \mapsto v} \} | \overline{v \in \values(T)} ]
\end{align*}

\end{document}

