// Based on: https://github.com/WayneJz/COMP6452-19T1/blob/master/Assignment_1/contracts/message.sol

contract LunchVote {
    // These are "consumable" because we can self-destruct, and consume all of these resources.
    // That's fine, because these resources don't have any meaning outside of the contract, so there's no need to preserve them.
    type Voter is nonfungible consumable asset address
    type LunchName is nonfungible consumable asset string

    quorum : nat
    voteAcceptedCount : nat
    maxVote : nat

    contractCreator : address

    // Syntax for linking is chosen to be similar to the map syntax, but using <=> to emphasize the bidrectional nature of the structure.
    // With curly brackets, to indicate that it stores a set of Voters; otherwise, people may expect it stores a single Voter
    // OTOH, kind of strange, because the syntax for a linking is "linking (KeyType <=> {ValType})"; the curly brackets are NOT part of the
    // value type.
    lunchChoices : linking LunchName <=> {Voter}
    // Alternate version, without curly brackets; avoiding the weird syntax but introducing the confusion.
    lunchChoices : linking LunchName <=> Voter

    // We also provide a "map": map address => nat
    // Intentionally using a word other than "mapping" because I think we should fix the weird behavior of Solidity's mappings, such as:
    // 1. Can't check if a key already exists
    // 2. Can't iterate through the keys
    // However, that means we also shouldn't call it a mapping, because that would suggest it works just like Solidity's.

    authorizedVoters : set Voter

    // This is a sort of ad-hoc way to represent states using flows
    // Using this because it works better with flows than having a boolean field.
    // Maybe we should have a real state system like Obsidian's
    CurrentlyVoting : set address
    VotingFinished : set address

    on create(quorumSet : nat):
        // The follow 'modes' of flow can be used:
        // --- x --> means "flow x"
        // +=        means "insert", so the resource is added to the set of resources held by the destination
        // No "consume" arrow, because it works differently than all the others: there's no destination.
        quorumSet --> quorum
        Voter[msg.sender] --> authorizedVoters
        contractCreator := msg.sender
        CurrentlyVoting += this.address

    transaction choiceCreator(choicesToAdd : set string):
        only when contractCreator = msg.sender

        // For loops don't really fit into the paradigm very well:
        // - Without loops, every transaction is a list of (conditional) flows and handlers)
        // - The program simply executes top to bottom, it never jumps back up.
        // See below for a suggestion on avoiding loops.
        // Here is the standard for loop version, below are several versions based on lambda-function-like constructs.
        for each choice in choicesToAdd:
            var name : LunchName
            LunchName[choice] --> name
            lunchChoices += name <=> {}

            // Alternate version:
            lunchChoices += link name with {}

        // Here's another version that treats flows as a stream of transformations and filtering
        // This is good because:
        // 1. Limits the number of concepts in the language.
        // 2. Unifies the various concepts of selectors (i.e., selecting a single value, select by predicate, selecting a set of values)
        // Perhaps at a usability cost? I think that basic functional programming-like ideas are now fairly common
        //  in mainstream languages, so developers will be used to them.
        // This part flows a user-specified set of LunchNames out of the LunchName source.
        LunchName --- choicesToAdd -->
            // Now we flow these all of these names into a function producing links, essentially
            //  taking the image of the set of the names we passed in
            (name |-> name <=> {}) -->
            // Finally, we flow all of these links into lunchChoices
            lunchChoices
        // Here's a one-line version of the same thing
        LunchName --- choicesToAdd --> (name |-> name <=> {}) --> lunchChoices
        // A version using the `transformer` keyword, because a potential confusing a function like this is that
        //  it not only does the transformation, but it will also store resources in a temporary location until they are flowed out of it.
        // The addition of `transformer` is meant to emphasize that it's not **exactly** a function.
        LunchName --- choicesToAdd --> transformer (name |-> name <=> {}) --> lunchChoices

        // I could imagine having a syntax like
        var t : transformer (LunchName -> Link[LunchName, Voter])
        // Then also allowing
        LunchName --- choicesToAdd --> t --> lunchChoices

        // Could also imagine having a built-in link creating function, so we could do:
        LunchName --- choicesToAdd --> createLink --> lunchChoices

        // The main issue I have with this is that we have a new construct that lets us "chain" flows.
        // However, this seems like a natural extension of flows.
        // If I were to write
        A --- x --> B --- y --> C
        // Given how flows work, it seems reasonable that this would transfer x from A to B, and then
        //  transfer y from B to C (assuming these transfers could be made).
        // That is,
        A --- x --> B --- y --> C
        =
        {
            A --- x --> B
            B --- y --> C
        }

        // An alternate version, avoiding the use of a loop via anonymous transactions.
        // Still functional style, but avoids the need for creating new
        LunchName --- choicesToAdd --> (name |-> lunchChoices += name <=> {})
        // A version using a more typical lambda notation (could also be \name ->, name =>, name ->, etc.)
        LunchName --- choicesToAdd --> (\name. lunchChoices += name <=> {})
        // A Scala-like lambda (using an underscore to mark the argument location)
        LunchName --- choicesToAdd --> (lunchChoices += _ <=> {})
        // A more verbose version, old Javascript-style anonymous function.
        LunchName --- choicesToAdd --> transaction(name : string) { lunchChoices += name <=> {} }

    transaction authorizeVoter(newVoterAddress : address):
        only when contractCreator = msg.sender

        Voter[newVoterAddress] --> authorizedVoters

    view getChoices() returns set string := { name | (name <=> voters) in lunchVotes }

    view getResult() returns string * set (string * nat) :=
        if this.address in CurrentlyVoting then
            return ("Voting still in progress! You can only use 'getChoices' function.", {})
        else
            let winners : set (string, nat) :=
                { (name, total voters) | (link name with voters) in lunchVotes, total voters = maxVote }

            if total winners > 1 then
                return ("The lunch vote has multiple tie winners:", winners)
            else
                return ("The winner is:", winners)

    transaction vote(voterChoice : string) returns string:
        only when this.address in CurrentlyVoting then
            authorizedVoters --- msg.sender --> lunchChoices[voterChoice]

            maxVote := max(maxVote, total lunchChoices[voterChoice])

            // authorizedVoters stores all the voters who are allowed to vote, but have not yet voted.
            // So total Voter - total authorizedVoters is the number of voters who have voted.
            if (total Voter - total authorizedVoters) >= quorum then
                CurrentlyVoting --- this.address --> VotingFinished

            return "Vote accepted."

    transaction deconstructor():
        only when msg.sender = contractCreator then
            this.balance --> msg.sender.balance

            // Consume all resources, include ourselves (a self-destruct).
            // In addition to self-destructing, this acts as a check that only consumable resources are held by this contract at this point.
            consume this
}

