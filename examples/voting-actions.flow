// Based on: https://github.com/WayneJz/COMP6452-19T1/blob/master/Assignment_1/contracts/message.sol

// Removed most code, keeping only the parts that are directly related to the "action" concept.
contract LunchVote {
    // These are "consumable" because we can self-destruct, and consume all of these resources.
    // That's fine, because these resources don't have any meaning outside of the contract, so there's no need to preserve them.
    type Voter is nonfungible consumable asset address
    source voterSource of Voter

    contractCreator : address

    authorizedVoters : set Voter

    event AuthorizedVoter(addr : address)

    on create():
        voterSource --- msg.sender --> authorizedVoters
        msg.sender ~~> contractCreator

    transaction authorizeVoter(newVoterAddress : address):
        only when contractCreator = msg.sender then
            // Actions: We name this flow "F" so we can refer to it later.
            // This version lets us attach multiple "actions" to F, which depend on the outcome of F
            // In this case, as there's only one flow in this transaction, there's not actually any need to name it.
            F: voterSource --- newVoterAddress --> authorizedVoters

            // Attach an "action" that occurs when the "trigger" activates.
            // Triggers only occur at the end of the transaction, providing protection from reentrancy
            //   in the way that Scilla does. The notable difference is that we allow checking the return value of contracts.
            //   Actions are otherwise processed in lexical order.

            // Syntax is currently:
            [action] TRIGGER: ACTION
            // It could be something like to emphasize that it doesn't happen when it is written.
            create/setup [action] TRIGGER : ACTION

            // Here, Err may contain more specific failure information, such as an error message
            on fail F with Err: revert("This address is already authorized! Do not re-authorize it.")
            // Alternate version with the "action" keyword.
            action on fail F with Err: revert("This address is already authorized! Do not re-authorize it.")

            // Events can also be handled via the action mechanism. Probably not really necessary; there shouldn't be
            //  any issues with having emit just look like it does in Solidity, but it does unify everything as an action.
            //  It also let's us easy trigger certain events "on fail"
            on success emit AuthorizedVoter(newVoterAddress)

            // This action isn't necessary for this transaction, but is the original motivation for this mechanism.
            // This type of external call is **required** by ERC-721, and also a couple other Ethereum standards and common patterns.
            // Obviously there's other kinds of external calls, but in my experience, this is sufficient for most contracts.
            on success F call newVoterAddress.receiveAuthorization()
                         returning resultCode such that resultCode = "SUCCESS"
            // The syntax for the above could omit the word "action" and only write the trigger.

            // Complete version below:
            F: voterSource --- newVoterAddress --> authorizedVoters
            on fail F with Err:
                revert("This address is already authorized! Do not re-authorize it.")
            on success F:
                emit AuthorizedVoter(newVoterAddress)
                call newVoterAddress.receiveAuthorization()
                    returning resultCode such that resultCode = "SUCCESS"

            // This version does the same (in this particlar case)
            voterSource --- newVoterAddress --> authorizedVoters
            on fail with Err: revert("This address is already authorized! Do not re-authorize it.")
            on success: emit AuthorizedVoter(newVoterAddress)
            on success: call newVoterAddress.receiveAuthorization()
                        returning resultCode such that resultCode = "SUCCESS"

            // A more typical looking approach:
            // Pros:
            // - Looks "normal"
            // Cons:
            // - More opportunity for reentrancy bugs.
            // - More complicated program structure (a transaction is just a list of actions/flows vs. having every construct that any other language would have)
            try {
                voterSource --- newVoterAddress --> authorizedVoters
            } catch (Err) {
                revert("This address is already authorized! Do not re-authorize it.")
            }
            emit AuthorizedVoter(newVoterAddress)
            if newVoterAddress.receiveAuthorization() != "SUCCESS" then
                revert();
}

