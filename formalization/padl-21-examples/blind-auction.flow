type Bid is consumable asset {
    sender : address,
    blindedBid : bytes,
    deposit : ether
}
type Reveal is { value : nat, fake : bool, secret : bytes }
type Message is consumable asset {
    sender : address,
    value : ether
}
type BlindAuction is asset {
    beneficiary : address,
    biddingEnd : nat,
    revealEnd : nat,
    ended : bool,
    bids : map address => list Bid,
    highestBidder : address,
    highestBid : ether,
    pendingReturns : map address => ether
}

transformer bid(this : BlindAuction, msg : Message, bid : bytes) {
    only when now <= this.biddingEnd
    [ new Bid(msg.sender, big, msg.value) ] --> this.bids[msg.sender]
}
transformer reveal(this : BlindAuction, msg : Message, reveals : list Reveal) {
    only when biddingEnd <= now and now <= revealEnd
    zip(this.bids[msg.sender], reveals)
        --[ any such that revealed(_) ]-> revealBid(this, _) --> placeBid(this, _)
}
transformer revealed(arg : { fst : Bid, snd : Reveal }) -> res : bool {
    keccak256(arg.snd.value, arg.snd.fake, arg.snd.secret) --> var hashed : bytes
    try {
        [ bid.blindedBid ] --[ hashed ]-> bid.blindedBid
        true --> res
    } catch {
        false --> res
    }
}
transformer revealBid(this : BlindAuction, arg : { fst : Bid, snd : Reveal }) -> toPlace : list { sender : address, value : ether } {
    arg.fst --> var bid : Bid
    arg.snd --> var reveal : Reveal

    try {
        only when not reveal.fake
        bid.deposit --[ reveal.value ]-> var value : ether
        [ { sender |-> fst.sender, value |-> value } ] --> toPlace
    } catch {
        // Don't place fake bid, just refund
    }

    // Refund the rest
    bid.deposit --> fst.sender.balance
}
transformer placeBid(this : BlindAuction, toPlace : { sender : address, value : ether }) {
    only when toPlace.value >= this.highestBid

    try {
        only when highestBidder != 0x0
        this.highestBid --> this.pendingReturns[msg.sender]
    } catch { }

    toPlace.sender --> highestBidder
    toPlace.value --> highestBid
}
transformer withdraw(this : BlindAuction, msg : Message) {
    this.pendingReturns[msg.sender] --> msg.sender.balance
}
transformer auctionEnd(this : BlindAuction) {
    only when now >= this.revealEnd and not this.ended
    true --> this.ended
    highestBid --> beneficiary.balance
}

