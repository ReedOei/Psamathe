\documentclass[10pt]{article}

\usepackage{amsmath}
\usepackage{sagetex}
\usepackage{hyperref}
\usepackage{tikz-cd}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bm}
\usepackage{listings}
\usepackage{bbm}
\usepackage{multicol}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{float}
\usepackage[inline]{enumitem}
\usepackage[margin=1.25in]{geometry}
\usepackage[T1]{fontenc}
\usepackage{kpfonts}

\usetikzlibrary{decorations.pathmorphing}

\input{LaTeX/macros.tex}
\input{macros.tex}

\begin{document}

\section{Specification}

\subsection{Syntax}
\begin{figure}[ht]
\begin{align*}
    C &\in \textsc{ContractNames} & m &\in \textsc{TransactionNames} \\
    t &\in \textsc{TypeNames} & x &\in \textsc{Identifiers} \\
    n &\in \Z \\
\end{align*}
\begin{tabular}{l r l l}
    $\mathfrak{q}$ & \bnfdef & $\exactlyone$ \bnfalt $\any$ \bnfalt $\nonempty$ & (selector quantifiers) \\
    $\mathcal{Q}$ & \bnfdef & $\mathfrak{q}$ \bnfalt $\emptyq$ \bnfalt $\every$ & (\typeQuantities) \\
    $\mathcal{C}$ & \bnfdef & $\optionq$ \bnfalt $\setq$ \bnfalt $\listq$ & (collection type constructors) \\
    % Removed product types for the moment because you don't really need them if you have records.
    % $T$ & \bnfdef & $\voidt$ \bnfalt \boolt \bnfalt $\natt$ \bnfalt $\mathcal{C}~\tau$ \bnfalt $\tau \times \tau$ \bnfalt $\tau \transforms \tau$ \bnfalt $\curlys{\overline{x : \tau}}$ \bnfalt $t$ & (base types) \\
    $T$ & \bnfdef & $\voidt$ \bnfalt \boolt \bnfalt $\natt$ \bnfalt $\mathcal{C}~\tau$ \bnfalt $\tau \transforms \tau$ \bnfalt $\curlys{\overline{x : \tau}}$ \bnfalt $t$ & (base types) \\
    $\tau$ & \bnfdef & $\mathcal{Q}~T$ & (types) \\
    $\mathcal{V}$ & \bnfdef & $n$ \bnfalt \true \bnfalt \false \bnfalt $\emptyq$ \bnfalt $\lambda x : \tau. E$ & (values) \\
    $\mathcal{L}$ & \bnfdef & $x$ \bnfalt $x[x]$ \bnfalt $x.x$ & (locations) \\
    $E$ & \bnfdef & $\mathcal{V}$ \bnfalt $\mathcal{L}$ \bnfalt $x.m(\overline{x})$ \bnfalt $\some(x)$ \bnfalt $\letvar~x:\tau := E~\varin~E$ \bnfalt $f \varin~x$ \bnfalt $\curlys{\overline{x : \tau \mapsto x}}$ & (expressions) \\
    % For the moment, removed these, but maybe put them back: $x \%$ \bnfalt $\min(f, f)$ \bnfalt $\max(f, f)$
    $s$ & \bnfdef & $\mathcal{L}$ \bnfalt $\everything$ \bnfalt $\mathfrak{q}~x : \tau~\suchthat~E$ & (selector) \\
    $\mathcal{N}$ & \bnfdef & $\mathcal{L}$ \bnfalt $\newc~C(\overline{x})$ \bnfalt $\consume$ & (nodes) \\
    $F$ & \bnfdef & $\mathcal{N} \sends{s} \mathcal{N}$ & (flows) \\
    $\Stmt$ & \bnfdef & $F$ \bnfalt $E$ \bnfalt $\revert(E)$ \bnfalt $\tryS~S~\catchS(x : \tau)~S$ \bnfalt $\ifS~x~\thenS~S~\elseS~S$ \\
            & \bnfalt & $\var~x:\tau := E$ \bnfalt $S;S$ \bnfalt \pack \bnfalt $\unpack(x)$ & (statements) \\
    $M$ & \bnfdef & \fungible \bnfalt \nonfungible \bnfalt \consumable \bnfalt \asset & (type declaration modifiers) \\
    $\mathcal{D}$ & \bnfdef & $x : \tau$ & (field) \\
                  & \bnfalt & $\type~t~\is~\overline{M}~T$ & (type declaration) \\
                  & \bnfalt & $\transaction~m(\overline{x : \tau})~\returns~x : \tau~\doC~S$ & (transactions) \\
                  & \bnfalt & $\view~m(\overline{x : \tau})~\returns~\tau := E$ & (views) \\
                  % & \bnfalt & $\oncreate(\overline{x : \tau})~\doC~S$ & (constructor) \\
    $\Con$ & \bnfdef & $\contract~C~\{~\overline{\mathcal{D}}~\}$ & (contracts) \\
    $\Prog$ & \bnfdef & $\overline{\Con}~;~S$ & (programs)

    % Maybe:  $\alpha$ & \bnfdef & & (row type variables) \\
\end{tabular}
\caption{Abstract syntax of \langName.}
\label{lang-syntax}
\end{figure}

In the surface language, ``collection types'' (i.e., $\mathcal{Q}~\mathcal{C}~\tau$ or a transformer) are by default $\any$, but all other types, like $\natt$, are $\exactlyone$.

\reed{Some simplification ideas}
\reed{Could get rid of selecting by locations and only allowed selecting with quantifiers, and just optimize things like $\exactlyone~x:\tau~\suchthat~x = y$ into a lookup.
Also, allowing \textbf{any} type quantity in a selector lets us do away with everything.
Would actually be even nicer if we allowed any type quantity to appear in the quantifier, because then we wouldn't even need a special rule for everything.}
\reed{We could also get rid of ``if'' and instead do something like $\any~x:\tau~\suchthat~\ifS~b~\thenS~x = y~\elseS~false$}

\reed{Contract types should be consumable assets by default (consuming a contract is a self-destruct?)}

\subsection{Statics}
\begin{figure}[ht]
\begin{tabular}{l r l l}
    $\Gamma$ & \bnfdef & $\emptyset$ \bnfalt $\Gamma, x : \tau$ & (type environments)
\end{tabular}
\label{type-env}
\end{figure}

\begin{definition}
    Define $\textbf{Quant} = \curlys{\emptyq, \any, \exactlyone, \nonempty, \every}$, and call any $\mathcal{Q} \in \textbf{Quant}$ a \emph{type quantity}.
    Define $\emptyq < \any < \,\, \exactlyone < \nonempty < \every$.
    % This makes $(\textbf{Quant}, \leq)$ into a complete lattice.
\end{definition}

\reed{Eliminate all the locations except for $x$ and then use flows to extract and put stuff back?}
\framebox{$\modifiers(T) = \overline{M}$} \textbf{Type Modifiers}
\begin{align*}
    \modifiers(T) =
    \begin{cases}
        \overline{M} & \tif (\type~T~\is~\overline{M}~T) \\
        \emptyset & \owise
    \end{cases}
\end{align*}

\framebox{$\tau~\asset$} \textbf{Asset Types}

\reed{The syntax for record ``fields'' and type environments is the same...could just use it}
\begin{align*}
    (\mathcal{Q}~T)~\asset \iff \mathcal{Q} \neq \emptyq \tand (& \asset \in \modifiers(T) \tor \\
                                                                & (T = \tau \transforms \sigma \tand \sigma~\asset) \tor \\
                                                                & (T = \mathcal{C}~\tau \tand \tau~\asset) \tor \\
                                                                & (T = \curlys{\overline{y : \sigma}} \tand \exists x : \tau \in \overline{y : \sigma}. (\tau~\asset)))
\end{align*}
\reed{It should be the case that a transformer can have an output of an asset type if and only if it has an input asset type (and it the case of curried transformers, that \textbf{some} input type is an asset).}

\framebox{$\tau~\consumable$} \textbf{Consumable Types}
\begin{align*}
    (\mathcal{Q}~T)~\consumable &\iff \consumable \in \modifiers(T) \tor \lnot((\mathcal{Q}~T)~\asset)
\end{align*}

\framebox{$\demote(\tau) = \sigma$}
\framebox{$\demote_*(T_1) = T_2$} \textbf{Type Demotion}
\begin{align*}
    \demote(\mathcal{Q}~T) &= \mathcal{Q}~\demote_*(T) \\
    \demote_*(\voidt) &= \voidt \\
    \demote_*(\natt) &= \natt \\
    \demote_*(\boolt) &= \boolt \\
    \demote_*(t) &= \demote_*(T) & \twhere \type~t~\is~\overline{M}~T \tand \asset \in \overline{M} \\
    \demote_*(\mathcal{C}~\tau) &= \mathcal{C}~\demote(\tau) \\
    \demote_*(\curlys{\overline{x : \tau}}) &= \curlys{\overline{x : \demote(\tau)}} \\
    \demote_*(\tau \transforms \sigma) &= \demote(\tau) \transforms \demote(\sigma)
\end{align*}

\framebox{$\Gamma \flowproves E : \tau \flowprovesout \Delta$} \textbf{Expression Typing}
\begin{mathpar}
    \inferrule*[right=Empty-Val]{
    }{ \Gamma \flowproves \emptyq : \emptyq~\mathcal{C}~\tau \flowprovesout \Gamma }

    \inferrule*[right=Demote-Lookup]{
    }{ \Gamma, x : \tau \flowproves x : \demote(\tau) \flowprovesout \Gamma, x : \tau }

    \inferrule*[right=Lin-Lookup]{
    }{ \Gamma, x : \tau \flowproves x : \tau \flowprovesout \Gamma }

    \inferrule*[right=Field-Lookup]{
        \Gamma \proves x : \curlys{\overline{y : \tau}} \flowproves \Gamma
        \and
        f : \sigma \in \overline{y : \tau}
    }{ \Gamma \flowproves x.f : \sigma \flowproves \Gamma }

    \inferrule*[right=Build-Rec]{
        \Gamma \flowproves \overline{y : \tau} \flowprovesout \Delta
    }{ \Gamma \flowproves \curlys{\overline{x : \tau \mapsto y}} \flowprovesout \Delta }

    \inferrule*[right=View-Call]{
        \contract~C~\{ \overline{\mathcal{D}} \}
        \and
        (\view~m(\overline{a : \tau})~\returns~\sigma := E) \in \overline{\mathcal{D}}
        \and
        \Gamma, x : C \flowproves \overline{y : \tau} \flowprovesout \Gamma, x : C
    }{ \Gamma, x : C \flowproves x.m(\overline{y}) : \sigma \flowprovesout \Gamma, x : C }

    % \inferrule*[right=Interface-Tx-Call]{
    %     \interface~I~\{ \overline{\mathcal{D_I}} \}
    %     \and
    %     (\transaction~m(\overline{a : \tau})~\returns~\sigma) \in \overline{\mathcal{D}_I}
    %     \and
    %     \Gamma \flowproves \overline{y : \tau} \flowprovesout \Gamma
    % }{ \Gamma, x : I \flowproves x.m(\overline{y}) : \sigma \flowprovesout \Gamma, x : C }

    \inferrule*[right=Internal-Tx-Call]{
        \contract~C~\{ \overline{\mathcal{D}} \}
        \and
        \dom(\fields(C)) \cap \dom(\Gamma) = \emptyset
        \\
        (\transaction~m(\overline{a : \tau})~\returns~\sigma~\doC~S) \in \overline{\mathcal{D}}
        \and
        \Gamma, \this : C \flowproves \overline{y : \tau} \flowprovesout \Gamma, \this : C
    }{ \Gamma, \this : C \flowproves \this.m(\overline{y}) : \sigma \flowprovesout \Gamma, \this : C }

    \inferrule*[right=If-Expr]{
        \Gamma \flowproves x : \boolt \flowprovesout \Gamma
        \and
        \Gamma \flowproves y : \tau \flowprovesout \Delta
        \and
        \Gamma \flowproves z : \tau \flowprovesout \Delta
    }{ \Gamma \flowproves (\ifS~x~\thenS~y~\elseS~z) : \tau \flowprovesout \Delta }

    \inferrule*[right=Transformer]{
        \Gamma, x : \tau \flowproves E : \sigma \flowprovesout \Gamma
    }{ \Gamma \flowproves (\lambda x : \tau. E) :: \emptyq~(\tau \transforms \sigma) }
\end{mathpar}

\framebox{$\fields(C) = \Gamma$} \textbf{Contract Fields}
\begin{align*}
    \fields(C) = \setbuild{\this.f : \tau}{f : \tau \in \overline{\mathcal{D}}} \twhere (\contract~C~\{ \overline{\mathcal{D}} \})
\end{align*}

\framebox{$\Gamma \proves \mathcal{S} :: \tau \flowsto_{\mathcal{Q}} \sigma$} \textbf{Storage Typing}
The syntax $\tau \flowsto_{\mathcal{Q}} \sigma$ means that the storage accepts $\tau$ and provides $\sigma$; that is, you can flow $\tau$ into it, and when you flow out of it, you get $\sigma$; moreover, you get at most $\mathcal{Q}$ of them.
\begin{mathpar}
    \inferrule*[right=Store-One]{
    }{ \Gamma, S : \tau \proves S :: \tau \flowsto_{\exactlyone} \tau }

    \inferrule*[right=Store-Col]{
    }{ \Gamma, S : \mathcal{Q}~\mathcal{C}~\tau \proves S :: \tau \flowsto_{\mathcal{Q}} \tau }

    \inferrule*[right=Store-Transformer]{
    }{ \Gamma, x : \mathcal{Q}~(\tau \transforms \sigma) \proves x :: \tau \flowsto_{\mathcal{Q}} \sigma }

    \inferrule*[right=Store-Consume]{
        \tau~\consumable
    }{ \Gamma \proves \consume :: \tau \flowsto_{\emptyq} \voidt }

    \inferrule*[right=Store-New]{
        \fields(C) = \overline{\this.f : \tau}
        \and
        \Gamma \flowproves \overline{y : \tau} \flowprovesout \Gamma
    }{ \Gamma \proves \newc~C(\overline{y}) :: \voidt \flowsto_{\exactlyone} ~ C }
\end{mathpar}

\framebox{$\Gamma \proves f ~\selects_\mathcal{Q}~ \tau$} \textbf{Selectors}
\begin{mathpar}
    \inferrule*[right=Select-One]{
        \Gamma \flowproves E : \tau \flowprovesout \Gamma
    }{ \Gamma \proves E~\selects_{\exactlyone}~\tau }

    \inferrule*[right=Select-Col]{
        \Gamma \flowproves E : \mathcal{Q}~\mathcal{C}~\tau \flowprovesout \Gamma
    }{ \Gamma \proves E~\selects_{\mathcal{Q}}~\tau }

    \inferrule*[right=Select-Everything]{
    }{ \Gamma \proves \everything~\selects_\every~\tau }

    \inferrule*[right=Select-Quant]{
        \Gamma, x : \tau \flowproves p : \boolt \flowprovesout \Gamma, x : \tau
    }{ \Gamma \proves (\mathfrak{q}~x : \tau~\suchthat~p)~\selects_\mathfrak{q}~\tau }
\end{mathpar}

\begin{definition}
    Let $\mathcal{Q}, \mathcal{R} \in \textbf{Quant}$.
    Define the commutative operator $\oplus$, called \emph{combine}, as the unique function $\textbf{Quant}^2 \to \textbf{Quant}$ satisfying
    \begin{align*}
        \every \oplus \mathcal{R} &= \every \\
        \emptyq \oplus \mathcal{R} &= \mathcal{R} \\
        \nonempty \oplus \mathcal{R} &= \nonempty \\
        \exactlyone \oplus \mathcal{R} &= \nonempty \qquad \tif \mathcal{R} \neq \emptyq \\
        \any \oplus \any &= \any
    \end{align*}

    Similarly, define the operator $\ominus$, called \emph{split}, as the unique function $\textbf{Quant}^2 \to \textbf{Quant}$ such that
    \begin{align*}
        \mathcal{Q} \ominus \emptyq & = \mathcal{Q} \\
        \emptyq \ominus \mathcal{R} & = \emptyq \\
        \exactlyone \ominus \mathcal{R} &= \emptyq \qquad \tif \mathcal{R} \geq \exactlyone \\
        \nonempty \ominus \mathcal{R} &= \any \qquad \tif \mathcal{R} \neq \emptyq \\
        \mathcal{Q} \ominus \any &= \any \\
        \mathcal{Q} \ominus \every & = \emptyq \\
        \every \ominus \mathcal{Q} &= \every
    \end{align*}
\end{definition}

Note that we write $(\mathcal{Q}~T) \oplus \mathcal{R}$ to mean $(\mathcal{Q} \oplus \mathcal{R})~T$ and similarly $(\mathcal{Q}~T) \ominus \mathcal{R}$ to mean $(\mathcal{Q} \ominus \mathcal{R})~T$.
$\mathcal{Q} \oplus \mathcal{R}$ represents the quantity present when flowing $\mathcal{R}$ of something to a storage already containing $\mathcal{Q}$.
$\mathcal{Q} \ominus \mathcal{R}$ represents the quantity left over after flowing $\mathcal{R}$ from a storage containing $\mathcal{Q}$.

\framebox{$\update(\Gamma, \mathcal{S}, \tau)$} \textbf{Type environment modification}
% These auxiliary functions are used to update the statically known information about a storage after flowing in or out of it (see the \textsc{Flow} rule).
\[
    \update(\Gamma, S, \tau) =
    \begin{cases}
        \Delta, S : \tau & \tif \Gamma = \Delta, S : \sigma \\
        \Gamma & \owise
    \end{cases}
\]

\begin{definition}
    We can consider a type environment $\Gamma$ as a function $\textsc{Identifiers}\xspace \to \textsc{Types}\xspace \cup \curlys{\bot}$ as follows:
    \[
        \Gamma(x) =
        \begin{cases}
            \tau & \tif x : \tau \in \Gamma \\
            \bot & \owise
        \end{cases}
    \]
    We write $\dom(\Gamma)$ to mean $\setbuild{x \in \textsc{Identifiers}}{\Gamma(x) \neq \bot}$.
\end{definition}

\begin{definition}
    Let $\mathcal{Q}$ and $\mathcal{R}$ be \typeQuantities, $T_\mathcal{Q}$ and $T_\mathcal{R}$ base types, and $\Gamma$ and $\Delta$ type environments.
    Define the following orderings, which make types and type environments into join-semilattices.
    For type quantities, define the partial order $\sqsubset$ by
    \[
        \mathcal{Q} \sqsubseteq \any; \quad \every \sqsubseteq \nonempty; \quad \exactlyone \sqsubseteq \nonempty
    \]
    For types, define the partial order $\leq$ by
    \[
        \mathcal{Q}~T_\mathcal{Q} \leq \mathcal{R}~T_\mathcal{R} \iff T_\mathcal{Q} = T_\mathcal{R} \tand \mathcal{Q} \sqsubseteq \mathcal{R}
    \]
    For type environments, define the partial order $\leq$ by
    \[
        \Gamma \leq \Delta \iff \forall x. \Gamma(x) \leq \Delta(x)
    \]
\end{definition}

\framebox{$\Gamma \flowproves S~\wf \flowprovesout \Delta$} \textbf{Statement Well-formedness}
\begin{mathpar}
    \inferrule*[right=Wf-Flow]{
        \Gamma \flowproves S :: \tau \flowsto_\mathcal{Q} \sigma
        \and
        \Gamma \flowproves f~\selects_\mathcal{R}~\demote(\sigma)
        \\
        \Delta = \update(\Gamma, S, \Gamma(S) \ominus \mathcal{R})
        \and
        \Delta \proves D :: \sigma \flowsto_\mathcal{S} \pi
    }{ \Gamma \flowproves (S \sends{s} D)~\wf \flowprovesout \update(\Delta, D, \Delta(D) \oplus \min(\mathcal{Q}, \mathcal{R})) }

    \inferrule*[right=Wf-Var-Def-Init]{
        \Gamma \flowproves E : \tau \flowprovesout \Gamma
        \and
        \Gamma, x : \tau \flowproves S~\wf \flowprovesout \Delta, x : \sigma
        \and
        \lnot(\sigma~\asset)
    }{ \Gamma \flowproves (\var~x : \tau := E~\varin~S)~\wf \flowprovesout \Delta }

    \inferrule*[right=Wf-If]{
        \Gamma \flowproves x : \boolt \flowprovesout \Gamma
        \and
        \Gamma \flowproves S_1~\wf \flowprovesout \Delta
        \and
        \Gamma \flowproves S_2~\wf \flowprovesout \Xi
    }{ \Gamma \flowproves (\ifS~x~\thenS~S_1~\elseS~S_2)~\wf \flowprovesout \Delta \vee \Xi }

    \inferrule*[right=Wf-Try]{
        \Gamma \flowproves S_1~\wf \flowprovesout \Delta
        \and
        \Gamma, x : \tau \flowproves S_2~\wf \flowprovesout \Xi, x : \tau
    }{ \Gamma \flowproves (\tryS~S_1~\catchS~(x : \tau)~S_2)~\wf \flowprovesout \Delta \vee \Xi }

    \inferrule*[right=Wf-Revert]{
        \Gamma \flowproves E : \tau \flowprovesout \Gamma
    }{ \Gamma \flowproves \revert(E)~\wf \flowprovesout \Gamma }

    \inferrule*[right=Wf-Expr]{
        \Gamma \flowproves E : \tau \flowprovesout \Gamma
    }{ \Gamma \flowproves E~\wf \flowprovesout \Gamma }

    \inferrule*[right=Wf-Seq]{
        \Gamma \flowproves S_1~\wf \flowprovesout \Delta
        \and
        \Delta \flowproves S_2~\wf \flowprovesout \Xi
    }{ \Gamma \flowproves (S_1 ; S_2)~\wf \flowprovesout \Xi }

    \inferrule*[right=Wf-Unpack]{
        \this.f : \tau \in \fields(C)
    }{ \Gamma, \this : C \flowproves \unpack(f)~\wf \flowprovesout \Gamma, \this : C, \this.f : \tau }

    \inferrule*[right=Wf-Pack]{
        (\Gamma|_{\dom(\fields(C))}) \leq \fields(C)
        \and
        \Delta = \setbuild{x : \tau \in \Gamma}{x \not\in \dom(\fields(C))}
    }{ \Gamma, \this : C \flowproves \pack~\wf \flowprovesout \Delta, \this : C }
\end{mathpar}

\framebox{$\proves_C \mathcal{D}~\wf$} \textbf{Declaration Well-formedness}
\begin{mathpar}
    \inferrule*[right=Wf-View]{
        \Gamma = \this : C, \fields(C), \overline{x : \tau}
        \and
        \Gamma \flowproves E : \sigma \flowprovesout \Gamma
    }{ \proves_C (\view~m(\overline{x : \tau})~\returns~\sigma := E)~\wf }

    \inferrule*[right=Wf-Tx]{
        \this : C, \fields(C), \overline{x : \tau}, y : \emptyq~T \flowproves S~\wf \flowprovesout \Delta, \this : C, y : \mathcal{Q}~T
        \\
        \dom(\fields(C)) \cap \dom(\Delta) = \emptyset
        \and
        \forall x : \tau \in \Delta. \lnot(\tau~\asset)
        \and
        \lnot(\mathcal{Q}~T~\asset)
    }{ \proves_C (\transaction~m(\overline{x : \tau})~\returns~y : \mathcal{Q}~T~\doC~S)~\wf }

    \inferrule*[right=Wf-Field]{
    }{ \proves_C (x : \tau)~\wf }

    \inferrule*[right=Wf-Type]{
    }{ \proves_C (\type~t~\is~\overline{M}~T)~\wf }
\end{mathpar}

\framebox{$\Con~\wf$} \textbf{Contract Well-formedness}
\begin{mathpar}
    \inferrule*[right=Wf-Con]{
        \forall d \in \overline{\mathcal{D}}. (\proves_C d~\wf)
    }{ (\contract~C~\{ \overline{\mathcal{D}} \})~\wf }
\end{mathpar}

\framebox{$\Prog~\wf$} \textbf{Program Well-formedness}
\begin{mathpar}
    \inferrule*[right=Wf-Con]{
        \forall C \in \overline{\Con}. C~\wf
        \and
        \emptyset \flowproves S \flowprovesout \Delta
        \and
        \forall x : \tau \in \Delta. \lnot(\tau~\asset)
    }{ (\overline{\Con} ; S)~\wf }
\end{mathpar}

\reed{Asset retention theorem?}
\reed{Resource accessiblity?}

\reed{What guarantees should we provide (no errors except for flowing a resource that doesn't exist in the source/already exists in the destination)?}

\section{Introduction}

\langName is a DSL for implementing programs which manage resources, targeted at writing smart contracts.

\subsection{Contributions}

We make the following main contributions:
\begin{itemize}
    \item \textbf{Safety guarantees}: similar to \reed{or maybe just exactly} linear types\reed{or maybe uniqueness types? need to read more about this}, preventing accidental resource loss or duplication.
        Additionally, provides some amount of reentrancy safety.

        \begin{itemize}
            \item We can evaluate these by formalizing the language and proving them; the formalization is something that would be nice to do anyway.
        \end{itemize}

    \item \textbf{Simplicity}: The language is quite simple---it makes writing typical smart contract programs easier and shorter, because many common pitfalls in Solidity are automatically handled by the language, such as overflow/underflow, checking of balances, short address attacks, etc.

        \begin{itemize}
            \item We can evaluate these by comparing LOC, cyclomatic complexity, etc.
                Not sure what the right metric would be.
                \reed{Or how cyclomatic complexity would work exactly in this language.}

            \item We can also evaluate via a user study, but that will take a long(er) time.
        \end{itemize}

    \item \reed{Optimizations?}
        Some of the Solidity contracts are actually inefficient because:
        \begin{enumerate}
            \item They use lots of modifiers which repeat checks (see reference implementation of ERC-721).
            \item They tend to use arrays to represent sets.
                Maybe this is more efficient for very small sets, but checking containment is going to be much faster with a \lstinline{mapping (X => bool)} eventually.
        \end{enumerate}

        \begin{itemize}
            \item We can evaluate this by profiling or a simple opcode count (which is not only a proxy for performance, but also means that deploying the contract will be cheaper).
        \end{itemize}
\end{itemize}


\section{Language Intro}

The basic state-changing construct in the language is a \emph{flow}.
A flow describes a transfer of a \emph{resource} from one \emph{storage} to another.
A \emph{transaction} is a sequence of flows and \emph{handlers}.

Each flow has a \emph{source}, a \emph{destination}, and a \emph{selector}.
The source and destination are two storages which hold a resource, and the selector describes which part of the resource in the source should be transferred to the destination.
A flow may optionally have a \emph{name}.

Note that all flows fail if they can't be performed.
For example, a flow of fungible resources fails if there is enough of the resource, and a flow of a nonfungible resource fails if the selected value doesn't exist in the source location.

NOTE: If we wanted to be "super pure", we can implement preconditions with just flows by doing something like:
\begin{lstlisting}
{ contractCreator = msg.sender } --[ true ]-> consume
\end{lstlisting}
This works because \lstinline|{ contractCreator = msg.sender } : set bool| (specifically, a singleton), so if \lstinline{contractCreator = msg.sender} doesn't evaluate to true, then we will fail to consume true from it.
I don't think actually doing this is a good idea; at least, not in the surface language.
Maybe it would simplify the compiler and/or formalization), but it's interesting/entertaining.

\paragraph{Actions}
A handler is a pair of a \emph{trigger} and an \emph{action}.
Triggers specify when an action should be executed.
An action can be:
\begin{enumerate}
    \item An event
    \item An external call
    \item An error handler
\end{enumerate}

\reed{For the moment, I think it is safe to allow constructors to act like a storage, and \textbf{not} like an external call.
This is because when you call a constructor, you must have the full source code of the contract you're going to make, and therefore you can be sure that the code it runs is safe.}
\reed{Can you do actions other than just providing an error message in on fail?}
\reed{Sending ether will also trigger an external call, which should be considered as being part of the \lstinline{on success} block, probably}

For example, below, we create a flow with a name \lstinline{F}.
\begin{lstlisting}
F: voterSource --- newVoterAddress --> authorizedVoters
\end{lstlisting}

We can then create handlers for this flow, such as the following:
\begin{lstlisting}
on fail F with Err:
    revert("This address is already authorized! Do not re-authorize it.")
on success F:
    emit AuthorizedVoter(newVoterAddress)
    call newVoterAddress.receiveAuthorization() asserting resultCode = "SUCCESS"
\end{lstlisting}

It's possible to have triggers which only occur when some subset of actions occurs.
Below, we create two flows.
The trigger \lstinline|on fail {F1,F2}| triggers when any one of the actions \lstinline{F1} or \lstinline{F2} fails.
The trigger \lstinline|on success {F1,F2}| triggers when \textbf{both} the actions \lstinline{F1} and \lstinline{F2} succeed.
\reed{Is this confusing, or is this how you would expect it to work?}
\begin{lstlisting}
F1: A --- x ---> B
F2: C --- y ---> D
on fail {F1,F2}:
    // Stuff
on success {F1,F2}:
    // Stuff
\end{lstlisting}

In fact, all handlers are internally translated into this form, so \lstinline{on fail F} becomes \lstinline|on fail {F}|, and \lstinline{on fail} becomes \lstinline|on fail {F1,F2,...,Fn}|, where \lstinline{F1}, \lstinline{F2}, ..., \lstinline{Fn} are all the flows preceeding the handler.
\reed{I think this is the right way to do it.}

We can also allow the following syntax to be used, with minimal additional implementation troubles:
\begin{lstlisting}
handle {
    A --- x --> B
    C --- y --> D
    E --- z --> F
} with {
    on fail:
        // Stuff
    on success:
        // Stuff
}
\end{lstlisting}

This can be mechanically rewritten to:
\begin{lstlisting}
F1: A --- x --> B
F2: C --- y --> D
F3: E --- z --> F
on fail {F1,F2,F3}:
    // Stuff
on success {F1,F2,F3}:
    // Stuff
\end{lstlisting}

\reed{random note}
The following pattern, while popular in Python \reed{and probably some other languages}, is not possible with this system.
\begin{lstlisting}
try
    A --- x --> B
    C --- y --> D
catch
    E --- z --> F
\end{lstlisting}

So that the second flow only happens if the first fails, you should instead just check whatever condition you're actually interested in.
I don't think this will greatly impact usability, and in fact is probably easier to read because the condition has to be specified, and you won't get unexpected failures causing the flow.
For example, say you want to do the third flow only when there isn't enough money in \lstinline{A} and \lstinline{C} for first two flows to occur.
But the above implementation would also cause the money to be taken from C in the case that there's, for example, and overflow when you transfer to B, or if A has enough money, but not C, which may is desirable.

\section{Examples}
\paragraph{Transfer with fees}
This is fairly common: for example, the contract with the most transactions does this, as do many gambling/auction contracts.
\eq{
    \texttt{transfer}(\texttt{from}, \texttt{to}, \texttt{amount}):
}
\begin{tikzcd}
    & & \mathcal{A}[\texttt{owner}] \\
    \mathcal{A}[\texttt{from}] \arrow{r}{\texttt{amount}} & \arrow{ur}{\texttt{fee} \%} \arrow[rightsquigarrow]{dr}{} & \\
    & & \mathcal{A}[\texttt{to}] \\
\end{tikzcd}

\subsection{The DAO attack}
We can prevent the DAO attack (the below is from \url{https://consensys.github.io/smart-contract-best-practices/known_attacks/}):
\begin{lstlisting}
function withdrawBalance() public {
    uint amountToWithdraw = userBalances[msg.sender];
    // At this point, the caller's code is executed, and can call withdrawBalance again
    require(msg.sender.call.value(amountToWithdraw)(""));
    userBalances[msg.sender] = 0;
}
\end{lstlisting}

In \langName, we would write this as:

\begin{lstlisting}
transaction withdrawBalance():
    userBalances[msg.sender] --> msg.sender.balance
\end{lstlisting}

Not only is this simpler, but the compiler can automatically place the actual call that does the transfer last, meaning that the mistake could simply never be made.

\subsection{approveAndCall}

Many token contracts include the concept of \lstinline{approveAndCall}, typically similarly to the following (taken from: \lstinline{0x174bfa6600bf90c885c7c01c7031389ed1461ab9}, one of the most popular contracts on the blockchain by transaction count):
\begin{lstlisting}
function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, address(this), _extraData);
        return true;
    }
}
\end{lstlisting}

In \langName, we can do the same thing by associating a call with a flow.
\begin{lstlisting}
transaction approveAndCall(_spender : address, _value : uint256, _extraData : bytes):
    consume everything from allowance[msg.sender, _spender]
    approvalSource --[ _value ]-> allowance[msg.sender, _spender],
    on success: call receiveApproval(msg.sender, _value, address(this), _extraData)
\end{lstlisting}

\section{Random Thoughts}
\reed{Ignore this for now, just some stuff for fun that may or may not end up being useful.}
\reed{At some point, maybe for antoher language, would like to figure out the more general type quantity thing where you can freely combine $\setq$ and $\listq$ and $\nonempty$ and $\one$, etc.}
\reed{Add at ``at most one'' quantity, which makes the \typeQuantities into a group?}
\reed{Free group of quantities list set and option makes teh type quantities we care about?
What are the inverses?}

\begin{align*}
    \nonempty &= \optionq^{-1} \\
\end{align*}
% Note: Consider $\tau \equiv \one~\tau$, so $x : \natt$ and $x : \one~\natt$ are the same (and so is $x : \one~\one~\natt$, etc.).
% Additionally, $\nonempty~\emptyq \equiv \one$, $\nonempty~\nonempty \equiv \nonempty$, \reed{$\emptyq~\nonempty \equiv \emptyq$?}

\begin{definition}
    \reed{Don't think this really has a good name}
    A \emph{resource} $\mathcal{R}$ is a tuple $(R, +, 0, \leq, -)$ where
    \begin{enumerate}[label=(\roman*)]
        \item $(R, +, 0)$ is a monoid.
        \item $(R, \leq)$ is a partial order that is compatible with $(R, +, 0)$.
            That is, for any $x, y \in R$ such that $x \leq y$, and for any $z \in R$, we have $x + z \leq y + z$.
        \item $- : R \times R \to R$ is a function so that for any $x,y \in R$ such that $y \leq x$, we have $(x - y) + y = x$.

        % NOTE: An alternate definition with splitting built-in.
        % \item $\splits$ is a function $R \times \parens{R \cup \curlys{\top}}^R \to R \times R$, where $\top$ is a value not in $R$ for which we define $r < \top$ for all $r \in R$.
        %     We write $r \stackrel{f}{\splits} (a,b)$ instead of $\splits(r, f) = (a,b)$.
        %     Let $f : R \to R \cup \curlys{\top}$ and $r \in R$.
        %     If $f(r) \leq r$, then $r \stackrel{f}{\splits} (a,b)$ such that $f(r) = b$ and $a + b = r$.
    \end{enumerate}
\end{definition}

\paragraph{Examples}

\begin{enumerate}
    \item The natural numbers with the standard operations is a resource $(\N, +, 0, \leq, -)$, where $-$ is \emph{saturating subtraction}: $n - m = 0$ if $m > n$.
    \item For any set $A$, we can build the resource $(\powerset{A}, \cup, \emptyset, \subseteq, \setminus)$, where $X \setminus Y$ is the set difference operation.
    \item Similarly, given any set $A$, we can build the resource $(\powersetfin{A}, \cup, \emptyset, \subseteq, \setminus)$; this resource is called the \emph{nonfungible resource on $A$}, written $\text{nf}(A)$.
    \item \reed{I have no idea if this is useful, but it's fun}
        The set of strings on an alphabet $\Sigma$ can be made into the \emph{prefix resource} $(\Sigma^*, \epsilon, \cdot, \leq_p, -_p)$ or the \emph{suffix resource} $(\Sigma^*, \epsilon, \cdot, \leq_s, -_s)$, where $\cdot$ is concatenation, $x \leq_p y$ if $x$ is a prefix of $y$ and similarly $x \leq_s y$ if $x$ is a suffix of $y$.
        The functions $-_p$ and $-_s$ are defined as follows:
        \[
            (x \cdot y) -_p x = y
        \]
        and
        \[
            (x \cdot y) -_s y = x
        \]
\end{enumerate}

\begin{definition}
    For any two resources $\mathcal{R}$ and $\mathcal{S}$, their \emph{direct product}, $\mathcal{R} \oplus \mathcal{S}$ is $(R \times S, +_{RS}, (0_R, 0_S), \leq_{RS}, -_{RS})$, where
    \begin{align*}
        (r_1, s_1) +_{RS} (r_2, s_2) &:= (r_1 +_R r_2, s_1 +_S s_2) \\
        (r_1, s_1) -_{RS} (r_2, s_2) &:= (r_1 -_R r_2, s_1 -_S s_2) \\
        (r_1, s_1) \leq_{RS} (r_2, s_2) &:\iff r_1 \leq_R r_2 \land s_1 \leq_S s_2
    \end{align*}
\end{definition}

\begin{definition}
    Let $\mathcal{R}$ be a resource and let $A$ be a set.
    The exponential resource $\mathcal{R}^A$ \reed{I suspect this would be an exponential, anyway} is defined so
    \[
        \mathcal{R}^A := (R^A, +, \bm{0}, \leq, -)
    \]
    where for $f,g \in R^A$, we define
    \begin{align*}
        \bm{0}(x) &:= 0 \\
        (f + g)(x) &:= f(x) + g(x) \\
        f \leq g &:\Leftrightarrow \forall x \in A. f(x) \leq g(x) \\
        (f - g)(x) &:= f(x) - g(x)
    \end{align*}

    Note that $f - g$ is only defined when $g \leq f$.
\end{definition}

\end{document}

