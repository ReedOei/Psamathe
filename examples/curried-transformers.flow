interface TokenBank {
    transaction transfer(from : address, to : address, _tokenToSend : nat)
}

contract TimeLockTrade {
    type Token is nonfungible asset nat

    trades : list (Token, Token)

    userA : address
    userB : address
    unlockTime : nat

    bank : TokenBank

    on create(bank : TokenBank, userA : address, userB : address, tokensA : list nat, tokensB : list nat, unlockTime : nat):
        var pairer : Token ~> Token ~> (Token, Token) := \a. \b. (a,b)
        var temp : list (Token ~> (Token, Token))
        new Token --[ tokensA ]-> pairer --> temp
        new Token --[ tokensB ]-> temp --> trades

        // Some alternatives
        // Zip:
        zip(new Token, new Token) --[ zip(tokensA, tokensB) ]-> trades

        this.userA := userA
        this.userB := userB

        this.unlockTime := unlockTime

        this.bank := bank

    view canClaim() returns bool := now > unlockTime

    transaction claim():
        only when msg.sender in {userA, userB} and canClaim()

        trades --> this.doTrade
        // Desugars into
        trades --[ everything ]-> this.doTrade --> consume

    private transaction doTrade(tokenA : Token, tokenB : Token):
        bank.transfer(userA, userB, tokenA)
        bank.transfer(userB, userA, tokenB)
}

