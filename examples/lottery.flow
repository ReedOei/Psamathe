// Based on: smartbugs-wild/contracts/0xffff0031d8768861b3172a7c7dc7d91b646f53db.sol

interface ERC20Interface {
    transaction transfer(to : address, tokens : nat) returns bool
}

// Need to ensure the Lottery contract knows what a REV token is
interface REV {
    transaction buy(value : ether, buyer : address) returns nat
    transaction exit()

    view myTokens() returns nat
    view myDividends(b : bool) returns nat
}

contract Lottery {
    /*==============================
    =            EVENTS            =
    ==============================*/
    event Deposit(amount : nat, depositer : address)
    event WinnerPaid(amount : nat, winner : address)

    /*=====================================
    =            CONFIGURABLES            =
    =====================================*/
    REV revContract;  //a reference to the REV contract
    owner : address
    openToPublic : bool // Is this lottery open for public use?
    ticketNumber : nat := 0 // Starting ticket number
    winningNumber : nat // The randomly generated winning ticket

    /*=======================================
    =            PUBLIC FUNCTIONS            =
    =======================================*/

    on create():
        REV(0x05215FCE25902366480696F38C3093e31DBCE69A) --> revContract
        true --> openToPublic
        0xc42559F88481e1Df90f64e5E9f7d7C6A34da5691 --> owner
        on success:
            resetLottery()

  /* Fallback function allows anyone to send money for the cost of gas which
     goes into the pool. Used by withdraw/dividend payouts.*/
    function() payable public { }

    transaction fallback(value : ether):
        value --> this.balance

    transaction deposit(value : ether):
        only when value >= 0.01 ether

        var origValue : nat := value

        value --> revContract.buy(msg.sender)
        emit Deposit(origValue, msg.sender)

        if msg.value > 0.01 ether then
            var extraTickets : nat := origValue / 0.01 ether
            extraTickets --> ticketNumber

        if ticketNumber >= winningNumber then
            revContract.exit()
            payDev(owner)
            payWinner(msg.sender)
            resetLottery()
        else
            1 --> ticketNumber

    //Number of REV tokens currently in the Lottery pool
    view myTokens() returns nat := revContract.myTokens()
    view myDividends() returns nat := revContract.myDividends(true)
    view ethBalance() returns nat := this.balance

    transaction returnAnyERC20Token(tokenAddress : address, tokenOwner : address, tokens : nat):
        only when msg.sender = owner and tokenAddress != address(revContract)

        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens)

    /*======================================
    =          INTERNAL FUNCTIONS          =
    ======================================*/

    //pay winner
    internal transaction payWinner(winner : address):
        var origBalance : nat := this.balannce
        this.balance --> winner.balance
        emit WinnerPaid(balance, winner)

    //donate to dev
    internal transaction payDev(dev : address):
        var amount : nat := this.balance / 10
        this.balance --[ amount ]-> dev.balance

    internal transaction resetLottery():
        ticketNumber := 1
        winningNumber := uint256(keccak256(block.timestamp, block.difficulty)) % 300

    transaction resetLotteryManually():
        only when msg.sender = owner
        ticketNumber := 1
        winningNumber := uint256(keccak256(block.timestamp, block.difficulty)) % 300
}

