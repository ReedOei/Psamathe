// Based on contract at: 0x04b227b5f44409fd48d768124925deaf2f75192e
// A common use for external calls is using a Token contract to manage transactions.

contract Token {
    view balanceOf(_owner : address) returns uint256

    transaction transfer(_to : address, _value : uint256) returns bool
}

contract lockEtherPay {
    token_reward : Token

    beneficiary : address
    start_time : uint256
    end_time : uint256

    initial : option address
    locked : option address
    released : option address

    owner : address

    event TokenReleased(beneficiary : address, token_amount : uint256)

    on create():
        token_reward := Token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6)
        beneficiary := 0xD0e05482D3E24929ffFdA2cb9A7c958d380B17aF
        owner := msg.sender
        this.address --> initial

    // NOTE: Normally, I would make this transaction into a view. However, we can't be sure that the external call really is a view
    // NOTE: There's no way to write this with the old system, which is a pretty major shortcoming, as delegating calls is fairly common...
    transaction tokenBalance() returns uint256:
        return token_reward.balanceOf(this)

    transaction lock() returns bool:
        only when msg.sender = owner
              // NOTE: This is also impossible to write with the old system
              and tokenBalance() > 0

        initial --[ this.address ]-> locked
  	    start_time := now
  	    end_time := start_time + 52 weeks

    view lockOver() returns bool := now > end_time

    // NOTE: This transactio nis not possible using the Obsidian-style system, unless we make
    //       tokenBalance and lockOver private; however, they were public in the original contract.
    transaction release() returns bool:
        only when msg.sender = owner and lockOver()

        locked --[ this.address ]-> released

        var token_amount : uint256 := tokenBalance()

        emit TokenReleased(beneficiary, token_amount)
        token_reward.transfer(beneficiary, token_amount)
}

