mod STREAMS is
    protecting NAT .
    protecting QID .
    protecting CONVERSION .

    sorts TyQuant Mode Ty BaseTy Expr Id Val MultisetVal Multiset .
    subsort Nat < TyQuant .
    subsort Val < Expr .
    subsort Val < MultisetVal < Multiset .
    subsort Expr < Multiset .
    subsort Id < Val .

    ops * oo : -> TyQuant [ctor] .
    ops asset nonasset : -> Mode [ctor] .

    op ___ : TyQuant Mode BaseTy -> Ty [ctor] .

    op unit : -> BaseTy [ctor] .
    op multiset_ : Ty -> BaseTy [ctor] .
    op _x_ : Ty Ty -> BaseTy [ctor] .
    op _->_ : Ty Ty -> BaseTy [ctor] .

    subsort Qid < Expr .
    op lambda_:_._ : Qid Ty Expr -> Val [ctor frozen] .

    op mt : -> MultisetVal [ctor] .
    op _,_ : MultisetVal MultisetVal -> MultisetVal [ctor comm assoc id: mt] .
    op _,_ : Multiset Multiset -> Multiset [ctor comm assoc id: mt] .
    op {_} : MultisetVal -> Val [ctor frozen] .
    op {_} : Multiset -> Expr [ctor frozen] .

    op id(_) : Nat -> Id [ctor] .

    op [_;_] : Val Val -> Val [ctor frozen] .
    op [_;_] : Expr Expr -> Expr [ctor frozen] .

    op __ : Expr Expr -> Expr [ctor] .

    ops zero fail : -> Val [ctor] .
    op sum : Expr -> Expr [ctor frozen] .
    op sub : Expr Expr -> Expr [ctor frozen] .

    op let[_;_]:=_in_ : Qid Qid Expr Expr -> Expr [ctor frozen] .
    op let[_]:=_in_ : Qid Expr Expr -> Expr [ctor frozen] .

    op try{_}catch{_} : Expr Expr -> Expr [ctor frozen] .

    op assert_is_in_ : Expr TyQuant Expr -> Expr [ctor frozen] .
    op groupWith : TyQuant Expr Expr Expr -> Expr [ctor frozen] .
    ops copy label : Expr -> Expr [ctor frozen] .

    vars Q R Q1 Q2 : TyQuant .
    vars X Y Z A B : Qid .
    vars T S T1 T2 : BaseTy .
    vars Tau Sigma Pi : Ty .
    vars M : Mode .
    vars V W V1 V2 Left Right : Val .
    vars E F E1 E2 E3 E4 : Expr .
    vars Vs Ws Taken1 Taken2 Rest Rest1 Rest2 : Multiset .
    vars N N1 N2 : Nat .
    vars I J K L K1 K2 : Id .

    op demote : Ty -> Ty .
    eq demote(Q M T) = Q nonasset demoteBase(T) .

    op demoteBase : BaseTy -> BaseTy .
    eq demoteBase(unit) = unit .
    eq demoteBase(multiset Tau) = multiset demote(Tau) .
    eq demoteBase(Tau x Sigma) = demote(Tau) x demote(Sigma) .
    eq demoteBase(Tau -> Sigma) = demote(Tau) -> demote(Sigma) .

    op _elem_ : Qid Multiset -> Bool .
    eq X elem (X, Vs) = true .
    eq X elem Vs = false [owise] .

    op freshVar : Multiset -> Qid .
    eq freshVar(Vs) = freshVar(0, '0, Vs) .
    op freshVar : Nat Qid Multiset -> Qid .
    eq freshVar(N, X, Vs) =
        if X elem Vs then
            freshVar(N + 1, qid(string(N + 1, 10)), Vs)
        else
            X
        fi .

    op varsOf : Expr -> Multiset .
    eq varsOf(X) = X .
    eq varsOf(lambda X : Tau . E1) = X, varsOf(E1) .
    eq varsOf(E1 E2) = varsOf(E1), varsOf(E2) .
    eq varsOf([E1 ; E2]) = varsOf(E1), varsOf(E2) .
    eq varsOf({ mt }) = mt .
    eq varsOf({ E1 }) = varsOf(E1) .
    eq varsOf({ E1, E2, Vs }) = varsOf(E1), varsOf({E2, Vs}) .
    eq varsOf(zero) = mt .
    eq varsOf(fail) = mt .
    eq varsOf(id(N)) = mt .
    eq varsOf(sum(E)) = varsOf(E) .
    eq varsOf(sub(E1, E2)) = varsOf(E1), varsOf(E2) .
    eq varsOf(let [ X ; Y ] := E1 in E2) = X, Y, varsOf(E1), varsOf(E2) .
    eq varsOf(let [ X ] := E1 in E2) = X, varsOf(E1), varsOf(E2) .
    eq varsOf(try { E1 } catch { E2 }) = varsOf(E1), varsOf(E2) .
    eq varsOf(assert E1 is Q in E2) = varsOf(E1), varsOf(E2) .
    eq varsOf(groupWith(Q, F, E1, E2)) = varsOf(F), varsOf(E1), varsOf(E2) .
    eq varsOf(label(E)) = varsOf(E) .
    eq varsOf(copy(E)) = varsOf(E) .

    op _[_/_] : Expr Expr Qid -> Expr .
    eq X[E / X] = E .
    eq X[E / Y] = X [owise] .
    ceq (lambda X : Tau . E1)[E / Y] = lambda X : Tau . (E1[E / Y])
        if not (X elem Y, varsOf(E)) .
    ceq (lambda X : Tau . E1)[E / Y] = lambda Z : Tau . (E1[Z / X][E / Y])
        if (X elem Y, varsOf(E)) /\
            Z := freshVar(varsOf(E1), X, Y, varsOf(E)) .
    eq zero[E / Y] = zero .
    eq fail[E / Y] = fail .
    eq id(N)[E / Y] = id(N) .
    eq [E1 ; E2][E / Y] = [E1[E / Y] ; E2[E / Y] ] .
    eq (E1 E2)[E / Y] = (E1[E / Y]) (E2[E / Y]) .
    eq { mt }[E / Y] = { mt } .
    eq { E1 }[E / Y] = { E1[E / Y] } .
    eq { E1, E2, Vs }[E / Y] = { (E1[E / Y]), (E2[E / Y]) } ++ ({ Vs }[E / Y]) .
    eq sum(E1)[E / Y] = sum(E1[E / Y]) .
    eq sub(E1, E2)[E / Y] = sub(E1[E / Y], E2[E / Y]) .
    ceq (let [ X ; Y ] := E1 in E2)[E / Z] = let [ X ; Y ] := E1[E / Z] in (E2[E / Z])
        if not(X elem (Z, varsOf(E))) /\
           not(Y elem (Z, varsOf(E))) .
    ceq (let [ X ; Y ] := E1 in E2)[E / Z] = (let [ A ; Y ] := E1 in (E2[A / X]))[E / Z]
        if X elem (Z, varsOf(E)) /\
           A := freshVar(Z, varsOf(E), X, Y, varsOf(E1), varsOf(E2)) .
    ceq (let [ X ; Y ] := E1 in E2)[E / Z] = let [ X ; A ] := E1[E / Z] in (E2[A / Y][E / Z])
        if not(X elem Z, varsOf(E)) /\
           Y elem Z, varsOf(E) /\
           A := freshVar(Z, varsOf(E), X, Y, varsOf(E1), varsOf(E2)) .

    ceq (let [ X ] := E1 in E2)[E / Y] = let [ X ] := E1[E / Y] in (E2[E / Y])
        if not(X elem Y, varsOf(E)) .
    ceq (let [ X ] := E1 in E2)[E / Y] = let [ Z ] := E1 in (E2[Z / X][E / Y])
        if X elem Y, varsOf(E) /\
           Z := freshVar(X, Y, varsOf(E1), varsOf(E2), varsOf(E)) .

    eq (try { E1 } catch { E2 })[E / Y] = try { E1[E / Y] } catch { E2[E / Y] } .
    eq (assert E1 is Q in E2)[E / Y] = assert (E1[E / Y]) is Q in (E2[E / Y]) .

    eq groupWith(Q, F, E1, E2)[E / Y] = groupWith(Q, F[E / Y], E1[E / Y], E2[E / Y]) .
    eq label(E1)[E / Y] = label(E1[E / Y]) .
    eq copy(E1)[E / Y] = copy(E1[E / Y]) .

    op unpackSingleton : Qid Expr Expr -> Expr .
    eq unpackSingleton(X, { E }, E2) = E2[E / X] .
    eq unpackSingleton(X, E, E2) = fail [owise] .

    op applyLabels : Nat Multiset -> Multiset .
    eq applyLabels(N, mt) = mt .
    eq applyLabels(N, (V, Vs)) = [ id(N) ; V ], applyLabels(N + 1, Vs) .

    op _++_ : Val Val -> Val [comm assoc] .
    eq { Vs } ++ { Ws } = { Vs, Ws } .
    eq [ V ; W ] ++ [ V1 ; V2 ] = [ V ++ V1 ; W ++ V2 ] .
    eq zero ++ V = V .
    eq fail ++ V = fail .

    op calculateSum : MultisetVal -> Val .
    eq calculateSum(mt) = zero .
    eq calculateSum(V, Vs) = V ++ calculateSum(Vs) .

    op |_| : Expr -> Nat .
    eq |{ mt }| = 0 .
    eq |{ E, Vs }| = 1 + | { Vs } | .
    eq | [ E1 ; E2 ] | = 1 .
    eq | zero | = 0 .

    op compatQuant : TyQuant Expr -> Bool .
    eq compatQuant(*, E) = true .
    eq compatQuant(N, E) = N == | E | .
    eq compatQuant(oo, lambda X : Tau . E) = true .
    eq compatQuant(Q, E) = false [owise] .

    op groupSize : MultisetVal MultisetVal -> Val .
    eq groupSize(Vs, mt) = [[{mt}; {mt}]; [{Vs}; {mt}]] .
    eq groupSize(mt, Vs) = [[{mt}; {mt}]; [{mt}; {Vs}]] .
    eq groupSize((V1, Vs), (V2, Ws)) = [[{V1}; {V2}]; [{mt}; {mt}]] ++ groupSize(Vs, Ws) .

    op partitionByKey : Val MultisetVal -> Val .
    eq partitionByKey(V, mt) = [ {mt} ; {mt} ] .
    eq partitionByKey(V, ([V ; V1], Rest)) = [{[V ; V1]}; {mt}] ++ partitionByKey(V, Rest) .
    eq partitionByKey(V, ([V1 ; V2], Rest)) = [{mt}; {[V1 ; V2]}] ++ partitionByKey(V, Rest) [owise] .

    op fsts : Multiset -> Multiset .
    eq fsts(mt) = mt .
    eq fsts([E1 ; E2], Rest) = E1, fsts(Rest) .
    op snds : Multiset -> Multiset .
    eq snds(mt) = mt .
    eq snds([E1 ; E2], Rest) = E2, snds(Rest) .

    vars G1 G2 G3 G4 : Multiset .
    op runGroupWith : TyQuant Val MultisetVal MultisetVal -> Multiset .
    eq runGroupWith(Q, F, mt, mt) = mt .
    ceq runGroupWith(Q, F, mt, ([V ; E], Rest)) = (F [V ; [{mt}; {snds(Vs)}]]), runGroupWith(Q, F, mt, Ws)
        if [{Vs} ; {Ws}] := partitionByKey(V, ([V ; E], Rest)) .
    ceq runGroupWith(Q, F, ([V ; E], Vs), Ws) =
        if Taken2 == mt then
            (F [V ; [{snds(Taken1)}; {mt}]]), runGroupWith(Q, F, Rest1, Rest2)
        else
            (F [V ; [{snds(G1)}; {snds(G2)}]]), runGroupWith(Q, F, (G3, Rest1), (G4, Rest2))
        fi

        if [{Taken1} ; {Rest1}] := partitionByKey(V, ([V ; E], Vs)) /\
           [{Taken2} ; {Rest2}] := partitionByKey(V, Ws) /\
           [[{G1}; {G2}]; [{G3}; {G4}]] := groupSize(Taken1, Taken2) .

    rl copy(E) => E .

    crl [E1 ; E2] => [V1 ; E2]
        if E1 => V1 /\ V1 =/= E1 .
    crl [V1 ; E2] => [V1 ; V2]
        if E2 => V2 /\ V2 =/= E2 .

    crl let [ X ; Y ] := E in E2 => E2[Left / X][Right / Y]
        if E => [ Left ; Right ] .
    crl let [ X ] := E1 in E2 => unpackSingleton(X, V, E2)
        if E1 => V .

    crl E1 E2 => E[V / X]
        if E1 => (lambda X : Tau . E) /\
           E2 => V .

    crl { E, Vs } => { V, Vs }
        if E => V /\ E =/= V .

    rl { fail, Vs } => fail .

    crl label(E1) => { applyLabels(0, Vs) }
        if E1 => { Vs } .

    crl try { E1 } catch { E2 } => if E1 == fail then E2 else E fi
        if E1 => E .

    crl sum(E1) => calculateSum(Vals:MultisetVal)
        if E1 => { Vals:MultisetVal } .

    crl assert E1 is Q in E2 =>
        if compatQuant(Q, E) then
            E2
        else
            fail
        fi

        if E1 => E .

    crl groupWith(Q, F, E1, E2) => { runGroupWith(Q, (lambda X : Tau . E), Vs, Ws) }
        if F => (lambda X : Tau . E) /\
           E1 => { Vs } /\
           E2 => { Ws } .

    ops map splitWith unzip : -> Val .
    eq map = lambda 'params : * nonasset unit .
        (let ['f ; 'xs] := 'params in groupWith(*,
                     lambda 'input : * nonasset unit .
                        (let ['k ; 'rest] := 'input in
                         let ['left ; 'right] := 'rest in
                         let ['head ] := 'left in
                         ('f 'head)), label('xs), {mt})) .
    eq splitWith = lambda 'params : * nonasset unit . let ['f ; 'xs] := 'params in sum(map ['f ; 'xs]) .
    eq unzip = lambda 'xs : * nonasset unit . (splitWith [ unzipPair ; 'xs ]) .

    ops unzipPair snd fst : -> Val .
    eq unzipPair = lambda 'pair : * nonasset unit . let ['x ; 'y] := 'pair in [{'x}; {'y}] .
    eq fst = lambda 'pair : * nonasset unit . let ['left ; 'right] := 'pair in 'left .
    eq snd = lambda 'pair : * nonasset unit . let ['left ; 'right] := 'pair in 'right .

    op splitKey : -> Val .
    eq splitKey = lambda 'params : * nonasset unit .
                    let ['k ; 'pair] := 'params in
                    let ['left ; 'right] := 'pair in
                    [{['k ; 'left]} ; {['k ; 'right]}] .

    op groupComponents : -> Val .
    eq groupComponents = lambda 'params : * nonasset unit .
                            let ['k ; 'pairs] := 'params in
                            let ['xs ; 'ys] := 'pairs in
                            ['k ; [sum('xs) ; sum('ys)]] .

    ops selectFst selectSnd : -> Val .
    eq selectFst = lambda 'valsF : * nonasset unit .
                    let ['vals ; 'f] := 'valsF in
                    let ['fsts ; 'snds] := splitWith [splitKey ; 'vals] in
                    let ['ret ; 'sel] := 'f 'fsts in
                    [groupWith(*, groupComponents, 'ret, 'snds); 'sel] .
    eq selectSnd = lambda 'valsF : * nonasset unit .
                    let ['vals ; 'f] := 'valsF in
                    let ['fsts ; 'snds] := splitWith [splitKey ; 'vals] in
                    let ['ret ; 'sel] := 'f 'snds in
                    [groupWith(*, groupComponents, 'fsts, 'ret); 'sel] .

    ops takeAll combine : -> Val .
    eq takeAll = lambda 'taggedVals : * nonasset unit . [{mt} ; map [snd ; 'taggedVals]] .
    eq combine = lambda 'toAdd : * nonasset unit . lambda 'takenVals : * nonasset unit .
                    let ['kv] := 'takenVals in
                    let ['key ; 'val] := 'kv in
                    [{['key ; sum({'val, 'toAdd})]}; {mt}] .

    op compose : -> Val .
    eq compose = lambda 'locs : * nonasset unit .
                    let ['f ; 'g] := 'locs in
                    (lambda 'valsK : * nonasset unit .
                        let ['vals ; 'k] := 'valsK in
                        ('f ['vals ; (lambda 'taggedVals : * nonasset unit . ('g ['taggedVals ; 'k]))])) .

    op flow : -> Val .
    eq flow = lambda 'locs : * nonasset unit .
                let ['src ; 'dst] := 'locs in
                (lambda 'valsK : * nonasset unit .
                    let ['vals ; 'k] := 'valsK in
                    let ['ret ; 'sel] := 'src ['vals ; takeAll] in
                    let ['ret2 ; 'sel2] := 'dst ['ret ; (combine sum('sel)) ] in
                    ('k 'ret2)) .

    ops runLocator runDestination : -> Val .
    eq runLocator = (lambda 'params : * nonasset unit .
                        let ['vals ; 'loc] := 'params in
                        let ['taggedRet ; 'sel] := 'loc [label('vals); takeAll] in
                        [map [snd ; 'taggedRet ]; 'sel]) .

    op wrapSingleton : -> Val .
    eq wrapSingleton = lambda 'pair : * nonasset unit . let ['k ; 'b] := 'pair in ['k ; {'b}] .

    op unwrapSingleton : -> Val .
    eq unwrapSingleton = lambda 'pair : * nonasset unit .
                            let ['k ; 'bs] := 'pair in
                            try { let ['b] := 'bs in ['k ; 'b] } catch { ['k ; zero] } .

    op eachK : -> Val .
    eq eachK = lambda 'g : * nonasset unit . lambda 'transformed : * nonasset unit .
                let ['ret ; 'sel] := 'g (map [wrapSingleton ; 'transformed]) in
                [ map [unwrapSingleton ; 'ret]; 'sel ] .

    op indexKey : -> Val .
    eq indexKey = lambda 'k : * nonasset unit . lambda 'idxVal : * nonasset unit .
                    let ['idx ; 'val] := 'idxVal in
                    [[ 'idx ; 'k ] ; 'val ] .

    op unindexKey : -> Val .
    eq unindexKey = lambda 'params : * nonasset unit .
                        let ['idxKey ; 'val] := 'params in
                        let ['idx ; 'key] := 'idxKey in
                        ['key ; ['idx ; 'val]] .

    op distributeKeys : -> Val .
    eq distributeKeys = lambda 'params : * nonasset unit .
                            let ['k ; 'vals] := 'params in
                            (map [indexKey 'k ; label('vals)]) .

    op sumSnds : -> Val .
    eq sumSnds = lambda 'params : * nonasset unit .
                    let ['k ; 'pairs] := 'params in
                    let ['xs ; 'ys] := 'pairs in
                    ['k ; sum('ys)] .

    op groupByIdx : -> Val .
    eq groupByIdx = lambda 'params : * nonasset unit .
                        let ['k ; 'pairs] := 'params in
                        let ['xs ; 'ys] := 'pairs in
                        ['k ; groupWith(*, sumSnds, 'xs, 'ys)] .

    op dropIdx : -> Val .
    eq dropIdx = lambda 'params : * nonasset unit .
                    let ['k ; 'idxVals] := 'params in
                    ['k ; map [snd ; 'idxVals ]] .

    op each : -> Val .
    eq each = lambda 'f : * nonasset unit .
                lambda 'listsG : * nonasset unit .
                    let ['lists ; 'g] := 'listsG in
                    let ['ret ; 'sel] := 'f [sum(map [distributeKeys ; 'lists]) ; eachK 'g ] in
                    --- [map [dropIdx ; groupWith(*, groupByIdx, {mt}, map [unindexKey ; 'ret])] ; 'sel] .
                    [groupWith(*, sumSnds, {mt}, map [dropIdx ; groupWith(*, groupByIdx, {mt}, map [unindexKey ; 'ret])]); 'sel] .

    --- TODO: sub
endm

--- set profile on .
--- set clear profile off .
red [ { zero, zero } ; { zero, zero } ] .
red let [ 'x ; 'y ] := [ zero ; zero ] in zero .

red demote(* asset multiset (1 asset multiset (oo asset (1 nonasset unit x 1 asset unit)))) .

rew let [ 'x ; 'y ] := [ zero ; zero ] in 'x .

rew let [ 'x ] := { zero } in 'x .
rew let [ 'x ] := { zero, zero } in 'x .

rew { (let [ 'x ] := { zero, zero } in 'x) , zero } .
rew { (let [ 'x ] := { zero } in 'x) , zero } .

rew label({ zero, zero, zero }) .

rew try { fail } catch { {zero, zero} } .

rew sum({ { zero }, { zero, zero } }) .

rew groupWith(*, (lambda 'pair : * nonasset unit . 'pair), label({zero}), label({zero})) .

rew unzip label({ { zero }, { zero, zero }}) .

rew selectFst [label({[zero ; zero]}); takeAll] .
rew runLocator [{[{zero, zero} ; zero]}; selectFst] .
rew runLocator [{[{zero, zero} ; zero]}; selectSnd] .

rew selectFst [label({[{zero,zero} ; zero]}) ; takeAll] .

rew (flow [selectFst ; selectSnd]) [label({[{zero,zero} ; zero]}); takeAll] .

rew runLocator [{[id(4) ; zero], [id(5) ; zero], [id(6) ; zero]}; selectFst] .
rew runLocator [{[[id(1) ; id(6)] ; id(2)]} ; compose [selectFst ; selectSnd]] .

rew runLocator [{{[id(4) ; zero], [id(5) ; zero]}, {[id(6) ; zero]}}; each selectFst] .

