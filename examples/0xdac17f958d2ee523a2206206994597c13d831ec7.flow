/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
    owner stores address

    /**
      * @dev The Ownable constructor sets the original `owner` of the contract to the sender
      * account.
      */
    on create():
        owner := msg.sender

    /**
    * @dev Allows the current owner to transfer control of the contract to a newOwner.
    * @param newOwner The address to transfer ownership to.
    */
    transaction transferOwnership(newOwner : address):
        only when newOwner != 0x0 and msg.sender = owner then
            owner := newOwner
}

asset token := fungible nat
sink destroyedTokens for token

/**
 * @title Basic token
 * @dev Basic version of StandardToken, with no allowances.
 */
contract BasicToken is Ownable, ERC20Basic {
    balances stores token by address

    // additional variables for use if transaction fees ever became necessary
    fee stores nat
    maximumFee stores nat

    /**
    * @dev transfer token for a specified address
    * @param _to The address to transfer to.
    * @param _value The amount to be transferred.
    */
    transaction transfer(_to: address, _value: nat):
        flow _value from balances[sender] to new Temp stores token
        flow min(fee%, maximumFee) from Temp to balances[owner]
        merge Temp into balances[_to]

    /**
    * @dev Gets the balance of the specified address.
    * @param _owner The address to query the the balance of.
    * @return An uint representing the amount owned by the passed address.
    */
    view balanceOf(_owner : address) of nat := balances[_owner]
}

/**
 * @title Standard ERC20 token
 *
 * @dev Implementation of the basic standard token.
 * @dev https://github.com/ethereum/EIPs/issues/20
 * @dev Based oncode by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
 */
contract StandardToken is BasicToken, ERC20 {
    allowed stores nat by (address, address)
    unlimited_allowance stores Set (address, address)

    /**
    * @dev Transfer tokens from one address to another
    * @param _from address The address which you want to send tokens from
    * @param _to address The address which you want to transfer to
    * @param _value uint the amount of tokens to be transferred
    */
    transaction transferFrom(_from : address, _to : address, _value : nat):
        if (_from, _to) not in unlimited_allowance then
            flow _value from allowed[_from, msg.sender] to nats

        flow _value from balances[_from] to new Temp stores token
        flow min(fee%, maximumFee) from Temp to balances[owner]
        merge Temp into balances[_to]

    /**
    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
    * @param _spender The address which will spend the funds.
    * @param _value The amount of tokens to be spent.
    */
    transaction approve(_spender : address, _value : nat):
        only when _value = 0 or allowed[msg.sender][_spender] = 0 then
            allowed[msg.sender][_spender] := _value

    transaction approveUnlimited(_spender : address):
        flow (msg.sender, _spender) from addressPool to unlimited_allowance

    /**
    * @dev Function to check the amount of tokens than an owner allowed to a spender.
    * @param _owner address The address which owns the funds.
    * @param _spender address The address which will spend the funds.
    * @return A uint specifying the amount of tokens still available for the spender.
    */
    view allowance(address _owner, address _spender) of nat := allowed[_owner][_spender]
}


/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Ownable {
    paused stores address
    unpaused stores address

    on create():
        flow this from addressSource to unpaused

  /**
   * @dev called by the owner to pause, triggers stopped state
   */
  transaction pause():
    only when msg.sender = owner then
        flow this from unpaused to paused

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  transaction unpause():
    only when msg.sender = owner then
        flow this from paused to unpaused
}

contract BlackList is Ownable, BasicToken {
    blacklist stores Set address

    /////// Getters to allow the same blacklist to be used also by other contracts (including upgraded Tether) ///////
    view getBlackListStatus(_maker : address) of bool := _maker in blacklist
    view getOwner() of address := owner

    transaction addBlackList(_evilUser : address):
        only when msg.sender = owner then
            flow _evilUser from addresses to blacklist
        // emit AddedBlackList(_evilUser);

    transaction removeBlackList(_clearedUser : address):
        only when msg.sender = owner then
            flow _evilUser from blacklist to addresses
        // emit RemovedBlackList(_clearedUser);

    transaction destroyBlackFunds(_blackListedUser : address):
        only when msg.sender = owner and _blackListedUser in blacklist then
            merge balances[_blackListedUser] into destroyedTokens
        // emit DestroyedBlackFunds(_blackListedUser, dirtyFunds);

    // No events yet:
    // event DestroyedBlackFunds(address _blackListedUser, uint _balance);
    // event AddedBlackList(address _user);
    // event RemovedBlackList(address _user);
}

contract UpgradedStandardToken is StandardToken {
    // those methods are called by the legacy contract
    // and they must ensure msg.sender to be the contract address
    transaction transferByLegacy(from : address, to : address, value : nat)
    transaction transferFromByLegacy(sender : address, from : address, address spender, value : nat)
    transaction approveByLegacy(from : address, spender : address, value : nat)
}

source tokenSource of token
sink tokenSink for token

contract TetherToken is Pausable, StandardToken, BlackList {
    name stores string
    symbol stores string
    decimals stores nat
    upgradedAddress stores address
    deprecated stores bool

    //  The contract can be initialized with a number of tokens
    //  All the tokens are deposited to the owner address
    //
    // @param _balance Initial supply of the contract
    // @param _name Token Name
    // @param _symbol Token symbol
    // @param _decimals Token decimals
    on create(_initialSupply : nat, _name : string, _symbol : string, _decimals : nat):
        flow _initialSupply from tokenSource to balances[owner]

        name := _name
        symbol := _symbol
        decimals := _decimals
        deprecated := false

    // Forward ERC20 methods to upgraded contract if this one is deprecated
    transaction transfer(_to : address, _value : nat):
        only when this not in paused and msg.sender not in blacklist then
            // Not super sure about this syntax
            if deprecated then
                UpgradedStandardToken(upgradedAddress).transferByLegacy(msg.sender, _to, _value);
            else
                super.transfer(_to, _value)

    // Forward ERC20 methods to upgraded contract if this one is deprecated
    transaction transferFrom(_from : address, _to : address, _value : nat):
        only when this not in paused and _from not in blacklist then
            if deprecated then
                UpgradedStandardToken(upgradedAddress).transferFromByLegacy(msg.sender, _from, _to, _value)
            else
                super.transferFrom(_from, _to, _value)

    // Forward ERC20 methods to upgraded contract if this one is deprecated
    view balanceOf(who : address) of nat :=
        if deprecated then
            UpgradedStandardToken(upgradedAddress).balanceOf(who)
        else
            super.balanceOf(who)

    // Forward ERC20 methods to upgraded contract if this one is deprecated
    transaction approve(_spender : address, _value : nat):
        if deprecated then
            UpgradedStandardToken(upgradedAddress).approveByLegacy(msg.sender, _spender, _value)
        else
            super.approve(_spender, _value)

    // Forward ERC20 methods to upgraded contract if this one is deprecated
    view allowance(_owner : address, _spender : address) of nat :=
        if deprecated then
            StandardToken(upgradedAddress).allowance(_owner, _spender)
        else
            super.allowance(_owner, _spender)

    // deprecate current contract in favour of a new one
    transaction deprecate(_upgradedAddress : address):
        only when msg.sender = owner then
            deprecated := true
            upgradedAddress := _upgradedAddress
            // emit Deprecate(_upgradedAddress);

    // deprecate current contract if favour of a new one
    view totalSupply() of nat :=
        if deprecated then
            StandardToken(upgradedAddress).totalSupply()
        else
            total token

    // Issue a new amount of tokens
    // these tokens are deposited into the owner address
    //
    // @param _amount Number of tokens to be issued
    transaction issue(amount : nat):
        only when msg.sender = owner then
            flow amount from tokenSource to balances[owner]
            // emit Issue(amount);

    // Redeem tokens.
    // These tokens are withdrawn from the owner address
    // if the balance must be enough to cover the redeem
    // or the call will fail.
    // @param _amount Number of tokens to be issued
    transaction redeem(amount : nat)
        only when msg.sender = owner then
            flow amount from balances[owner] to tokenSink
            // emit Redeem(amount);

    transaction setParams(newBasisPoints : nat, newMaxFee : nat)
        // Ensure transparency by hardcoding limit beyond which fees can never be added
        only when msg.sender = owner and newBasisPoints < 20 and newMaxFee < 50 then
            basisPointsRate := newBasisPoints;
            maximumFee := newMaxFee.mul(10**decimals);
            // emit Params(basisPointsRate, maximumFee);
    }

    // Called when new token are issued
    // event Issue(uint amount);

    // Called when tokens are redeemed
    // event Redeem(uint amount);

    // Called when contract is deprecated
    // event Deprecate(address newAddress);

    // Called if contract ever adds fees
    // event Params(uint feeBasisPoints, uint maxFee);
}
