\documentclass[sigconf]{acmart}

\usepackage{listings}
\usepackage{hyperref}
\usepackage{tikz-cd}
% \usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bm}
\usepackage{listings}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{float}
\usepackage{subcaption}
% \usepackage[inline]{enumitem}

%% \BibTeX command to typeset BibTeX logo in the docs
% \AtBeginDocument{%
%   \providecommand\BibTeX{{%
%     \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
% \setcopyright{acmcopyright}
% \copyrightyear{2018}
% \acmYear{2018}
% \acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
% \acmConference[Woodstock '18]{Woodstock '18: ACM Symposium on Neural
%   Gaze Detection}{June 03--05, 2018}{Woodstock, NY}
% \acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%   June 03--05, 2018, Woodstock, NY}
% \acmPrice{15.00}
% \acmISBN{978-1-4503-XXXX-X/18/06}

%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

\input{LaTeX/macros.tex}
\input{macros.tex}

\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{\langName}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
% \author{Reed Oei}
% \email{reedoei2@illinois.edu}
% \affiliation{%
%   \institution{University of Illinois at Urbana-Champaign}
%   \city{Urbana}
%   \country{USA}
% }

%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Trovato and Tobin, et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
    Abstract.
\end{abstract}

%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{datasets, neural networks, gaze detection, text tagging}

%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

\langName is a DSL for implementing programs which manage resources, targeted at writing smart contracts.

\subsection{Contributions}

We make the following main contributions:
\begin{itemize}
    \item \textbf{Safety guarantees}: similar to \reed{or maybe just exactly} linear types\reed{or maybe uniqueness types? need to read more about this}, preventing accidental resource loss or duplication.
        Additionally, provides some amount of reentrancy safety.

        \begin{itemize}
            \item We can evaluate these by formalizing the language and proving them; the formalization is something that would be nice to do anyway.
        \end{itemize}

    \item \textbf{Conciseness}: \langName is simple---it makes writing typical smart contract programs more concise, because many common patterns are automatically handled by the language; these include handling overflow/underflow, checking of balances, short address attacks \reed{Do this}, string operations, etc.
        This conciseness is not only an improvement for a developers workflow, but also means that such issues are automatically handled, making it impossible for developers to forget them \reed{Wording}.

        \begin{itemize}
            \item We can evaluate these by comparing LOC, cyclomatic complexity, etc.
                Not sure what the right metric would be.
                \reed{Or how cyclomatic complexity would work exactly in this language.}

            \item We can also evaluate via a user study, but that will take a long(er) time.
        \end{itemize}

    \item \reed{Optimizations? Probably don't have time for this, unfortunately.}
        Some of the Solidity contracts are actually inefficient because:
        \begin{enumerate}
            \item They use lots of modifiers which repeat checks (see reference implementation of ERC-721).
            \item They tend to use arrays to represent sets.
                Maybe this is more efficient for very small sets, but checking containment is going to be much faster with a \lstinline{mapping (X => bool)} eventually.
        \end{enumerate}

        \begin{itemize}
            \item We can evaluate this by profiling or a simple opcode count (which is not only a proxy for performance, but also means that deploying the contract will be cheaper).
        \end{itemize}
\end{itemize}


\section{Language Intro}

The basic state-changing construct in the language is a \emph{flow}.
A flow describes a transfer of a \emph{resource} from one \emph{storage} to another.
A \emph{transaction} is a sequence of statements.

Each flow has a \emph{source}, a \emph{destination}, and a \emph{selector}.
The source and destination are two storages which hold a resource, and the selector describes which part of the resource in the source should be transferred to the destination.
A flow may optionally have a \emph{name}.

Note that all flows fail if they can't be performed.
For example, a flow of fungible resources fails if there is enough of the resource, and a flow of a nonfungible resource fails if the selected value doesn't exist in the source location.

\subsection{Syntax}
\begin{figure}[t]
\begin{tabular}{l r l l}
    $\mathfrak{q}$ & \bnfdef & $\exactlyone$ \bnfalt $\any$ \bnfalt $\nonempty$ & (selector quantifiers) \\
    $\mathcal{Q}$ & \bnfdef & $\mathfrak{q}$ \bnfalt $\emptyq$ \bnfalt $\every$ & (\typeQuantities) \\
    $\mathcal{C}$ & \bnfdef & $\optionq$ \bnfalt $\setq$ \bnfalt $\listq$ & (collection constructors) \\
    % Removed product types for the moment because you don't really need them if you have records.
    % $T$ & \bnfdef & $\voidt$ \bnfalt \boolt \bnfalt $\natt$ \bnfalt $\mathcal{C}~\tau$ \bnfalt $\tau \times \tau$ \bnfalt $\tau \transforms \tau$ \bnfalt $\curlys{\overline{x : \tau}}$ \bnfalt $t$ & (base types) \\
    $T$ & \bnfdef & \boolt \bnfalt $\natt$ \bnfalt $\mathcal{C}~\tau$ \bnfalt $t$ \bnfalt $\ldots$ & (base types) \\
    $\tau$ & \bnfdef & $\mathcal{Q}~T$ & (types) \\
    $\mathcal{V}$ & \bnfdef & $n$ \bnfalt \true \bnfalt \false \bnfalt $\emptyval$ \bnfalt $\ldots$ & (values) \\
    $\mathcal{L}$ & \bnfdef & $x$ \bnfalt $x[x]$ \bnfalt $x.x$ & (locations) \\
    $E$ & \bnfdef & $\mathcal{V}$ \bnfalt $\mathcal{L}$ \bnfalt $x = x$ \bnfalt $x \neq x$ \bnfalt $\ldots$ & (expressions) \\
    % For the moment, removed these, but maybe put them back: $x \%$ \bnfalt $\min(f, f)$ \bnfalt $\max(f, f)$
    $s$ & \bnfdef & $\mathcal{L}$ \bnfalt $\everything$ \bnfalt $\mathfrak{q}~x : \tau~\suchthat~E$ & (selector) \\
    % $\mathcal{N}$ & \bnfdef & $\mathcal{L}$ \bnfalt $\newc~C(\overline{x})$ \bnfalt $\newc~t$ \bnfalt $\consume$ & (nodes) \\
    % $F$ & \bnfdef & $\mathcal{N} \sends{s} \mathcal{N}$ & (flows) \\
    $\mathcal{S}$ & \bnfdef & $\mathcal{L}$ \bnfalt $\newc~t$ & (sources) \\
    $\mathcal{D}$ & \bnfdef & $\mathcal{L}$ \bnfalt $\consume$ & (destinations) \\
    $F$ & \bnfdef & $\mathcal{S} \sends{s} x \to \mathcal{D}$ & (flows) \\
    $\Stmt$ & \bnfdef & $F$ \bnfalt $S;S$ \bnfalt $\emit~E(\overline{x})$ \bnfalt $\ldots$ & (statements) \\
    $M$ & \bnfdef & \fungible \bnfalt \nonfungible & \\
        & \bnfalt & \consumable \bnfalt \asset & (type modifiers) \\
    $\Decl$ & \bnfdef & $\ldots$ & \\
            & \bnfalt & $\event~E(\overline{x : \tau})$ & (event declaration) \\
            & \bnfalt & $\type~t~\is~\overline{M}~T$ & (type declaration) \\
            & \bnfalt & $\transaction~m(\overline{x : \tau})~\returns~x : \tau~\doC~S$ & (transactions) \\
    $\Con$ & \bnfdef & $\contract~C~\{~\overline{\Decl}~\}$ & (contracts) \\
\end{tabular}
\caption{Abstract syntax of \langName.}
\label{lang-syntax}
\end{figure}

\paragraph{The DAO attack}
We can prevent the DAO attack (the below is from \url{https://consensys.github.io/smart-contract-best-practices/known_attacks/}):
\begin{lstlisting}
function withdrawBalance() public {
    uint amountToWithdraw = userBalances[msg.sender];
    // At this point, the caller's code is executed, and can call withdrawBalance again
    require(msg.sender.call.value(amountToWithdraw)(""));
    userBalances[msg.sender] = 0;
}
\end{lstlisting}

In \langName, we would write this as:

\begin{lstlisting}
transaction withdrawBalance():
    userBalances[msg.sender] --> msg.sender.balance
\end{lstlisting}

Not only is this simpler, but the compiler can automatically place the actual call that does the transfer last, meaning that the mistake could simply never be made.

\section{Code Examples}

\reed{NOTE: I removed the MAX\_UINT thing that gives an unlimited approval from ERC20.sol, because that's not part of the standard and not particularly interesting.}
\reed{Cite properly Solidity code properly}

% \begin{figure}
%     \begin{subfigure}[t]{0.5\textwidth}
%         \lstinputlisting{splash20-examples/erc20.sol}
%         \caption{Solidity}
%     \end{subfigure}%
%     \begin{subfigure}[t]{0.5\textwidth}
%         \lstinputlisting{splash20-examples/erc20.flow}
%         \caption{\langName}
%     \end{subfigure}
%     \caption{A Solidity and a \langName implementation of the core functions of the ERC-20 standard.}
%     \label{fig:erc20-impl}
% \end{figure}

\section{Discussion}

\section{Conclusion}

%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{biblio}

%%
%% If your work has an appendix, this is the place to put it.
\appendix

\section{Appendix}

\end{document}
\endinput

