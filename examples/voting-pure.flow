// Based on: https://github.com/WayneJz/COMP6452-19T1/blob/master/Assignment_1/contracts/message.sol

contract LunchVote {
    // These are "consumable" because we can self-destruct, and consume all of these resources.
    // That's fine, because these resources don't have any meaning outside of the contract, so there's no need to preserve them.
    type Voter is nonfungible consumable asset address
    source voterSource of Voter

    type LunchName is nonfungible consumable asset string
    source lunchNameSource of LunchName

    quorum : nat
    voteAcceptedCount : nat
    maxVote : nat

    contractCreator : address

    // A linking is like a mapping, but is bidirectional, so you can do something like lunchChoices.linkedTo(voter),
    //  which will return which key is linked to the SET containing voter.
    //  This is a useful operation: you don't need a separate mapping keeping track of the same information,
    //  which would require several operations to make a single change; this is what the reference implementation of ERC-721
    //  does, which introduces more potential for errors (at least, that's my assumption).
    // Syntax below is chosen to be similar to the map syntax, but using --- to emphasize the bidrectional nature of the structure.
    // With curly brackets, to indicate that it stores a set of Voters; otherwise, people may expect it stores a single Voter
    // OTOH, kind of strange, because the syntax for a linking is "linking (KeyType--- {ValType})"; the curly brackets are NOT part of the
    // value type.
    lunchChoices : linking LunchName <=> {Voter}
    // Alternate version, without curly brackets; avoiding the weird syntax but introducing the confusion.
    lunchChoices : linking LunchName <=> Voter

    // Also provide a "map": map address => nat
    // Intentionally using a word other than "mapping" because I think we should fix the weird behavior of Solidity's maps, such as:
    // 1. Can't check if a key already exists
    // 2. Can't iterate through the keys

    authorizedVoters : set Voter

    // This is a sort of ad-hoc way to represent states using flows
    // Using this because it works better with flows than having a boolean field.
    // Maybe we should have a real state system like Obsidian's
    CurrentlyVoting : set address
    VotingFinished : set address

    on create(quorumSet : nat):
        // The follow 'modes' of flow can be used:
        // --- x --> means "flow x"
        // +=        means "hold", so the resource is added to the set of resources held by the destination
        // No "consume" arrow, because it works differently than all the others: there's no destination.
        quorumSet --> quorum
        voterSource --- msg.sender --> authorizedVoters
        contractCreator := msg.sender
        CurrentlyVoting += this.address

    transaction choiceCreator(choicesToAdd : set string):
        only when contractCreator = msg.sender then
            // TODO: For loops are convenient, but sort of weird and don't really fit into the paradigm very well.
            for each choice in choicesToAdd:
                var name : LunchName
                lunchNameSource --- choice --> name
                lunchChoices += name <=> {}

                // Alternate version:
                lunchChoices += link name with {}

    transaction authorizeVoter(newVoterAddress : address):
        only when contractCreator = msg.sender then
            voterSource --- newVoterAddress --> authorizedVoters

        // NOTE: If we wanted to be "super pure", we can implement precondition with just flows by doing something like:
        consume true from { contractCreator = msg.sender }
        // This works because { contractCreator = msg.sender } : set bool (specifically, a singleton), so
        //  if `contractCreator = msg.sender` doesn't evaluate to true, then we will fail to consume true from it.
        // I don't think actually doing this is a good idea; at least, not in the surface language.
        // Maybe it would simplify the compiler and/or formalization), but it's interesting/entertaining.

    view getChoices() returns set string := { name | (link name with voters) in lunchVotes }

    view getResult() returns string * set (string * nat) :=
        if this.address in CurrentlyVoting then
            return ("Voting still in progress! You can only use 'getChoices' function.", {})
        else
            let winners : set (string, nat) :=
                { (name, total voters) | (link name with voters) in lunchVotes, total voters = maxVote }

            if total winners > 1 then
                return ("The lunch vote has multiple tie winners:", winners)
            else
                return ("The winner is:", winners)

    transaction vote(voterChoice : string) returns string:
        only when this.address in CurrentlyVoting then
            authorizedVoters --- msg.sender --> lunchChoices[voterChoice]

            maxVote := max(maxVote, total lunchChoices[voterChoice])

            // authorizedVoters stores all the voters who are allowed to vote, but have not yet voted.
            // So total Voter - total authorizedVoters is the number of voters who have voted.
            if (total Voter - total authorizedVoters) >= quorum then
                CurrentlyVoting --- this.address --> VotingFinished

            return "Vote accepted."

    transaction deconstructor():
        only when msg.sender = contractCreator then
            this.balance --> msg.sender.balance

            // Consume all resources, include ourselves (a self-destruct).
            // In addition to self-destructing, this acts as a check that only consumable resources are held by this contract at this point.
            consume this
}

