contract TronToken {
    asset token := fungible nat

    source tokenSource of token
    sink tokenSink for token

    name stores string := "Tronix"      //  token name
    symbol stores string := "TRX"           //  token symbol
    decimals stores nat := 6            //  token digit

    balanceOf stores token by address
    allowance stores nat by (address, address)

    stopped stores bool := false

    constant valueFounder : nat := 100000000000000000
    owner : address := 0x0

    view isOwner() of bool := msg.sender = owner
    view isRunning() of bool := not stopped
    view validAddress() of bool := 0x0 != msg.sender

    on create(_addressFounder : address):
        owner := msg.sender
        flow valueFounder from tokenSource to balanceOf[_addressFounder]
        // emit Transfer(0x0, _addressFounder, valueFounder);

    transaction transfer(_to : address, _value : nat):
        only when isRunning() and validAddress() then
            flow _value from balanceOf[msg.sender] to balanceOf[_to]
            // emit Transfer(msg.sender, _to, _value);

    transaction transferFrom(_from : address, _to : address, _value : nat):
        only when isRunning() and validAddress() then
            flow _value from allowance[_from][msg.sender] to nats
            flow _value from balanceOf[_from] to balanceOf[_to]
            // emit Transfer(_from, _to, _value);

    transaction approve(_spender : address, _value : nat):
        only when isRunning() and validAddress() and _value = 0 or allowance[msg.sender][_spender] = 0 then
            allowance[msg.sender][_spender] := _value
            // emit Approval(msg.sender, _spender, _value);

    transaction stop():
        only when isOwner() then
            stopped := true

    transaction start():
        only when isOwner() then
            stopped := false

    transaction setName(_name : string):
        only when isOwner() then
            name := _name

    transaction burn(_value : nat):
        // MY NOTE: This is not a "true" burn, it's just a transfer that can never be recovered.
        flow _value from balanceOf[msg.sender] to balanceOf[0x0]
        // emit Transfer(msg.sender, 0x0, _value);

    // event Transfer(address indexed _from, address indexed _to, uint256 _value);
    // event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

