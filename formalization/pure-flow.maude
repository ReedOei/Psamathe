mod FLOW is
    protecting QID .
    protecting NAT .

    sorts TyQuant BaseTy Ty Source Dest Stmt Mod Mods .

    subsort Mod < Mods .

    sorts Loc Locs .
    subsort Qid < Loc < Locs .
    subsort Loc < Source .
    subsort Loc < Dest .

    op _._ : Loc Qid -> Loc [ctor] .
    ops True False : -> Loc [ctor] .
    op loc : Nat -> Loc [ctor] .

    op nil : -> Locs [ctor] .
    op _,_ : Locs Locs -> Locs [ctor assoc id: nil] .

    op mt : -> Mods [ctor] .
    op __ : Mods Mods -> Mods [ctor comm assoc id: mt] .

    ops empty any one nonempty every : -> TyQuant [ctor] .
    op bool : -> BaseTy [ctor] .
    op v : Qid -> BaseTy [ctor] .
    op t : Qid Mods BaseTy -> BaseTy [ctor] .
    op list : Ty -> BaseTy [ctor] .

    op __ : TyQuant BaseTy -> Ty [ctor] .

    op emptylist : -> Source [ctor] .
    op [_] : Loc -> Source [ctor] .
    op new : Qid Mods BaseTy -> Source [ctor] .

    op consume : -> Dest [ctor] .
    op var_:_ : Qid Ty -> Dest [ctor] .

    sort Selector .
    op __:_st_(_) : TyQuant Qid Ty Qid Locs -> Selector [ctor] .

    op _-->_ : Source Dest -> Stmt [ctor] .
    op _--[_]->_ : Source Selector Dest -> Stmt [ctor] .
    op _--[_]->_(_)-->_ : Source Selector Qid Locs Dest -> Stmt [ctor] .
    op done : -> Stmt [ctor] .

    sort Val Vals .
    subsort Bool < Val < Vals .

    op nil : -> Val [ctor] .
    op __ : Vals Vals -> Vals [ctor assoc id: nil] .

    sort Result .
    subsort Vals < Result < Stmt .
    op error : -> Result [ctor] .

    op select : Vals Selector -> Result .

    sorts Lookup Env Config .
    op mt : -> Env [ctor] .
    op _|->_ : Nat Vals -> Env [ctor] .
    op _,_ : Env Env -> Env [ctor comm assoc id: mt] .

    op mt : -> Lookup [ctor] .
    op _|->_ : Loc Nat -> Lookup [ctor] .
    op _,_ : Lookup Lookup -> Lookup [ctor comm assoc id: mt] .

    op [_,_,_,_] : Nat Lookup Env Stmt -> Config [ctor] .

    vars T T1 T2 : BaseTy .
    vars Tau Sigma Pi : Ty .
    vars Q R : TyQuant .
    vars X Y Z F Alpha Beta : Qid .
    var M : Mod .
    var Ms : Mods .
    vars A S : Source .
    vars B D : Dest .
    vars L L1 L2 : Loc .
    var Ls : Locs .
    vars V W V1 V2 : Val .
    vars Vs Ws : Vals .
    var Res : Result .

    var Sel : Selector .

    var Lookup : Lookup .
    var Store : Env .

    vars Counter N : Nat .

    op resolve : Lookup Env Source -> Nat .
    op resolve : Dest -> Dest .

    crl [ Counter, Lookup, Store, S --> D] =>
        if resolve(Lookup, Store, S) => Vs .

    --- rl [ Store, select(nil, one X : Tau st F(Ls)) ] => [ Store, error ] .
    --- rl [ Store, select(nil, nonempty X : Tau st F(Ls)) ] => [ Store, error ] .
    --- crl [ Store, select(nil, Q X : Tau st F(Ls)) ] => [ Store, nil ]
    ---     if Q =/= one /\ Q =/= nonempty .

    --- crl [ Store, select(Vs V Ws, one X : Tau st F(Ls)) ] => [ Store, V ]
    ---     if NewLoc := freshLoc(Store) /\
    ---        call(F, (Ls, NewLoc)) => Res /\ Res =/= error /\
    ---        --- We should not be able to select any more values.
    ---        select(Vs Ws, one X : Tau st F(Ls)) => error .
endm

rew (True --> var 'b : one bool) .
--- rew (True --[ one 'x : one bool st 'idBool(nil) ]-> var 'b : one bool) .

