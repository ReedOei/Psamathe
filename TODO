- How to figure out where to put stuff (e.g., memory, calldata, storage, etc.)?
    - Can we do this automatically and easily?

- If we flow a non-asset into a storage that already holds it, is that an error or is it okay?
- If we try to consume a non-asset that doesn't exist, is that an error or is it okay?

- Should we have require() or `only when`.
    - I like `only when`, but it is harder to provide error messages, so maybe require is the way to go.

- Automatic optimizations:
    - We will typically track "total" for an asset automatically (i.e., the amount in circulation + the amount in any given storage)
        - However, if never used, then we can omit it.
    - In a `flow one x such that P from A to B`, we can detect when the condition P will always designate at most one object and then do an early exit when we're doing the search.
    - This is somewhat starting to enter query-optimizer-land, so probably out of scope.

    - If we use checking to see if a key is in a mapping, then we create a separate mapping (X => bool) to store this info, otherwise we don't.
        - Of course, depends exactly how we compile, if we ever get around to actually implementing the langauge.

- Also, how exactly does this whole subtyping/value demotion thing work?
    - For example, I can write (atm, anyway), `_tokenId in balances[addr]`, where
        balances stores many token by addr

        and

        _tokenId : nat

- We should allow string equality tests, and just do the keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b)) thing under the hood.

- How to represent states
    - Not really happy with the standard solidity way of doing states
    - I feel like we can use flows to make this work nicely.
    - We can have a surface-level syntax that becomes preconditions like

        this in Paused

    - And we can then translate each state into a declaration

        Paused stores many address
        Unpaused stores many address

    - And state transitions (e.g., ->Unpaused) become:

        flow this from Paused to Unpaused

- What about storages that don't have any value in them?
    - For example, when I declare:

    x stores address

    does it HAVE to store an address?

    - I think yes.
    - If you flow a value out of a storage that contains exactly one value (e.g., x stores t and you do flow everything from x to ...) that's not okay, you have to merge or hold it.
    - Don't want to unnecessarily introduce "null" if I can avoid it.
    - Related: How to handle merging fields from a contract?
        e.g., merge this.balance into msg.sender.balance
        - You might do this before you destroy the contract
        - We could use something like Obsidian does, and only care that the transaction leaves the contract in a valid state.
        - This is kind of like my initial ideas of making the transaction into a graph that does a single, atomic change.

- Instead of payable: only functions that have a parameter that stores ether can receive ether
    - Also, can have at most one parameter with type ether

- How to handle inheritance and interfaces, if at all?
    - Related: how to interface with Solidity or Obsidian code, if needed?

- Maybe visualize transactions via diagrams, like the ones I've been drawing

- Fungible and non-fungible resources actually behave very similarly, so might be easy to combine into some parametric polymorphism.
    - Should we do this?
    - What syntax should we use for sets and maps?
        I like:

        votes stores many Vote

        and

        balances stores token by address

        for sets and maps, respectively.

    - I also think it would be nice to have polymorphism, but it is somewhat at odds with not allowing any helper methods...

- Token is kind of like an existential type, sealed inside ERC-20 bank
    - I was really thinking of it more like a path-dependent type.
    - Not sure what the "right" way is.

- What should be part of the static contract construct and what should be an instance?
    - e.g., should resources, sinks be static or dynamically created.
    - Not being able to this makes it kind of awkward to make a token exchange, for example.

- Look at other applications that are not ERC-20 and try to write them.
    - Try other research projects examples?
        - https://dl.acm.org/doi/proceedings/10.5555/3355356
    - Implement other proofs of concept
    - Maybe look at the testnet too (is there a corpus available here?)
    - That one voting application I found is somewhat interesting.

- See how we can represent things like database operations declaratively that people use
    - Maybe we only need to support cheap operations.
    - Look at examples of Fabric stuff, because Fabric has a database

- Potential contributions:
    - Maybe it's more readable?
        - Could be evaluated
    - Asset safety theorem/general discussion of safety properties.
    - Expressiveness
        - Sample 10 random ERC-20 tokens, can we express them?
    - Potential for optimization?

